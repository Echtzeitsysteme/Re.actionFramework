/**
 * generated by Xtext 2.19.0
 */
package org.reaction.dsl.validation;

import com.google.common.base.Objects;
import com.google.common.collect.Lists;
import com.google.inject.Inject;
import java.util.ArrayList;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.util.SimpleAttributeResolver;
import org.eclipse.xtext.validation.Check;
import org.reaction.dsl.interpreter.Calculator;
import org.reaction.dsl.reactionLanguage.AbstractAgent;
import org.reaction.dsl.reactionLanguage.Agent;
import org.reaction.dsl.reactionLanguage.AgentInstance;
import org.reaction.dsl.reactionLanguage.ArithmeticExpr;
import org.reaction.dsl.reactionLanguage.BlankPattern;
import org.reaction.dsl.reactionLanguage.Bond;
import org.reaction.dsl.reactionLanguage.BondSide;
import org.reaction.dsl.reactionLanguage.BondSideOrWildcard;
import org.reaction.dsl.reactionLanguage.BondType;
import org.reaction.dsl.reactionLanguage.Bonds;
import org.reaction.dsl.reactionLanguage.Complex;
import org.reaction.dsl.reactionLanguage.Div;
import org.reaction.dsl.reactionLanguage.FunctionCall;
import org.reaction.dsl.reactionLanguage.InitialisationBody;
import org.reaction.dsl.reactionLanguage.InitialisationHead;
import org.reaction.dsl.reactionLanguage.MathFunc;
import org.reaction.dsl.reactionLanguage.Observable;
import org.reaction.dsl.reactionLanguage.ObservablePattern;
import org.reaction.dsl.reactionLanguage.Pattern;
import org.reaction.dsl.reactionLanguage.Rates;
import org.reaction.dsl.reactionLanguage.ReactionLanguagePackage;
import org.reaction.dsl.reactionLanguage.ReactionModel;
import org.reaction.dsl.reactionLanguage.Rule;
import org.reaction.dsl.reactionLanguage.RuleBody;
import org.reaction.dsl.reactionLanguage.RuleHead;
import org.reaction.dsl.reactionLanguage.RuleType;
import org.reaction.dsl.reactionLanguage.Signature;
import org.reaction.dsl.reactionLanguage.SiteInstance;
import org.reaction.dsl.reactionLanguage.SiteInstanceState;
import org.reaction.dsl.reactionLanguage.TerminateBody;
import org.reaction.dsl.reactionLanguage.TerminateCount;
import org.reaction.dsl.reactionLanguage.TerminateIterations;
import org.reaction.dsl.reactionLanguage.VarRef;
import org.reaction.dsl.reactionLanguage.Variable;
import org.reaction.dsl.reactionLanguage.Wildcard;
import org.reaction.dsl.validation.AbstractReactionLanguageValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class ReactionLanguageValidator extends AbstractReactionLanguageValidator {
  @Inject
  private Calculator calculator;
  
  @Check
  public void checkMultipleSiteCalls(final Bonds bonds) {
    final List<SiteInstance> siList = EcoreUtil2.<SiteInstance>getAllContentsOfType(bonds, SiteInstance.class);
    for (int i = 0; (i < (siList.size() - 1)); i++) {
      {
        final SiteInstance si = siList.get(i);
        for (int j = (i + 1); (j < siList.size()); j++) {
          {
            final SiteInstance si2 = siList.get(j);
            EObject _eContainer = si.eContainer();
            final BondSide bondSide = ((BondSide) _eContainer);
            EObject _eContainer_1 = si2.eContainer();
            final BondSide bondSide2 = ((BondSide) _eContainer_1);
            final AbstractAgent aiAbstr = bondSide.getAbstractAgent();
            final AbstractAgent aiAbstr2 = bondSide2.getAbstractAgent();
            if (((aiAbstr instanceof AgentInstance) && (aiAbstr2 instanceof AgentInstance))) {
              final AgentInstance ai = ((AgentInstance) aiAbstr);
              final AgentInstance ai2 = ((AgentInstance) aiAbstr2);
              if ((si.getSite().getName().equals(si2.getSite().getName()) && ai.getName().equals(ai2.getName()))) {
                this.error("Multiple site calls within a single pattern are not allowed", 
                  ReactionLanguagePackage.Literals.BONDS__BONDS);
              }
            }
          }
        }
      }
    }
  }
  
  @Check
  public void checkIllegalInitialisationStates(final InitialisationBody initBody) {
    Pattern _pattern = initBody.getPattern();
    final Pattern pattern = ((Pattern) _pattern);
    if ((pattern instanceof BlankPattern)) {
      this.error("Cannot initialize empty pattern", ReactionLanguagePackage.Literals.INITIALISATION_BODY__PATTERN);
    } else {
      final List<Bond> initBonds = EcoreUtil2.<Bond>getAllContentsOfType(pattern, Bond.class);
      for (final Bond initBond : initBonds) {
        {
          final BondSideOrWildcard rhs = initBond.getRight();
          final BondType bondType = initBond.getBondType();
          if ((rhs instanceof BondSideOrWildcard)) {
            if (((((BondSideOrWildcard) rhs).getWildcard() != null) && Objects.equal(bondType, BondType.BOUND))) {
              this.error("Cannot use underspecified agents in initializations.", initBond, 
                ReactionLanguagePackage.Literals.BOND__BOND_TYPE);
            }
          }
        }
      }
    }
  }
  
  @Check
  public void genericAgentOnLeftSide(final Bond bond) {
    final AbstractAgent abstractAgent = bond.getLeft().getAbstractAgent();
    if ((abstractAgent instanceof Agent)) {
      this.error("Cannot use generic Agents on left site of bond.", bond.getLeft(), 
        ReactionLanguagePackage.Literals.ABSTRACT_AGENT__NAME);
    }
  }
  
  @Check
  public void combinationWildcardAndBondtype(final Bond bond) {
    final BondSideOrWildcard rbs = bond.getRight();
    final BondType bondType = bond.getBondType();
    if (((rbs != null) && (rbs.getWildcard() != null))) {
      if ((Objects.equal(bondType, BondType.BOUND) && rbs.getWildcard().isNothing())) {
        this.error("Wrong use of wildcard. Try \"+?\" or \"//0\".", ReactionLanguagePackage.Literals.BOND__RIGHT);
      }
      if ((Objects.equal(bondType, BondType.UNBOUND) && rbs.getWildcard().isAnything())) {
        this.error("Wrong use of wildcard. Try \"+?\" or \"//0\".", ReactionLanguagePackage.Literals.BOND__RIGHT);
      }
    }
  }
  
  @Check
  public void checkNoEmptyObservable(final ObservablePattern obs) {
    Pattern _pattern = obs.getPattern();
    if ((_pattern instanceof BlankPattern)) {
      this.error("Cannot observe empty pattern", ReactionLanguagePackage.Literals.OBSERVABLE_PATTERN__PATTERN);
    }
  }
  
  @Check
  public void checkNoEmptyTerminate(final TerminateCount tc) {
    Pattern _pattern = tc.getPattern();
    if ((_pattern instanceof BlankPattern)) {
      this.error("Cannot match for empty pattern", ReactionLanguagePackage.Literals.TERMINATE_COUNT__PATTERN);
    }
  }
  
  @Check
  public void checkNoLoopsInVariable(final Variable aVar) {
    final List<VarRef> referencedVars = EcoreUtil2.<VarRef>getAllContentsOfType(aVar, VarRef.class);
    for (final VarRef referencedVar : referencedVars) {
      String _name = referencedVar.getRef().getName();
      String _name_1 = aVar.getName();
      boolean _equals = Objects.equal(_name, _name_1);
      if (_equals) {
        this.error("Cannot self-reference in own expression", this.getNameFeature(referencedVar));
      } else {
        ArrayList<Variable> list = Lists.<Variable>newArrayList();
        list.add(aVar);
        Variable _ref = referencedVar.getRef();
        if ((_ref instanceof Variable)) {
          Variable _ref_1 = referencedVar.getRef();
          this.checkNoArithmeticLoops(((Variable) _ref_1), list);
        }
      }
    }
  }
  
  @Check
  public void checkNoMissingSiteInstanceOnLeftBondSide(final Bond bond) {
    final BondSide leftSide = bond.getLeft();
    final SiteInstance siteInstance = leftSide.getSiteInstance();
    if (((siteInstance == null) && Objects.equal(bond.getBondType(), BondType.BOUND))) {
      this.error("No connections on agents allowed but only on sites", bond, 
        ReactionLanguagePackage.Literals.BOND__LEFT);
    }
  }
  
  @Check
  public void checkNoDeadRule(final Rule rule) {
    boolean _equals = rule.getBody().getRhs().equals(rule.getBody().getLhs());
    if (_equals) {
      this.warning("Rule is dead.", rule, ReactionLanguagePackage.Literals.RULE__BODY);
    }
  }
  
  @Check
  public void checkRuleConcreteness(final Rule rule) {
    final Pattern lhs = rule.getBody().getLhs();
    final Pattern rhs = rule.getBody().getRhs();
    boolean _isConcrete = this.isConcrete(lhs, rhs);
    boolean _not = (!_isConcrete);
    if (_not) {
      this.error("Rule is underspecified", rule, ReactionLanguagePackage.Literals.RULE__BODY);
    }
    RuleType _ruleType = rule.getBody().getRuleType();
    boolean _equals = Objects.equal(_ruleType, RuleType.BI);
    if (_equals) {
      boolean _isConcrete_1 = this.isConcrete(rhs, lhs);
      boolean _not_1 = (!_isConcrete_1);
      if (_not_1) {
        this.error("Backwards rule is underspecified", rule, ReactionLanguagePackage.Literals.RULE__BODY);
      }
    }
  }
  
  private boolean isConcrete(final Pattern lhs, final Pattern rhs) {
    if ((rhs instanceof BlankPattern)) {
      if ((lhs instanceof BlankPattern)) {
        return true;
      }
      final EList<Bond> leftBonds = ((Bonds) lhs).getBonds();
      for (final Bond bond : leftBonds) {
        {
          final BondSideOrWildcard rightBondSide = bond.getRight();
          if (((rightBondSide != null) && (!(rightBondSide instanceof BondSide)))) {
            boolean _isAnything = rightBondSide.getWildcard().isAnything();
            if (_isAnything) {
              return false;
            }
          }
        }
      }
      return true;
    }
    final List<AgentInstance> agentsLeftSide = this.getAgentsSpecifiedInPattern(lhs);
    final EList<Bond> bonds = ((Bonds) rhs).getBonds();
    for (final Bond bond_1 : bonds) {
      {
        AbstractAgent _abstractAgent = bond_1.getLeft().getAbstractAgent();
        final AgentInstance agentInstance = ((AgentInstance) _abstractAgent);
        final SiteInstance siteInstance = bond_1.getLeft().getSiteInstance();
        if (((siteInstance != null) && this.unOrUnderspecifiedInPattern(agentInstance, siteInstance, lhs))) {
          boolean _bindingIsTheSameRightAsLeftWithoutState = this.bindingIsTheSameRightAsLeftWithoutState(agentInstance, siteInstance, lhs, rhs);
          boolean _not = (!_bindingIsTheSameRightAsLeftWithoutState);
          if (_not) {
            return false;
          }
        }
        BondSideOrWildcard _right = bond_1.getRight();
        boolean _tripleEquals = (_right == null);
        if (_tripleEquals) {
          boolean _contains = agentsLeftSide.contains(agentInstance);
          if (_contains) {
            boolean _unOrUnderspecifiedInPattern = this.unOrUnderspecifiedInPattern(agentInstance, lhs);
            boolean _not_1 = (!_unOrUnderspecifiedInPattern);
            if (_not_1) {
              return false;
            }
          }
        } else {
          final BondSideOrWildcard rightBondSideOrWild = bond_1.getRight();
          if ((rightBondSideOrWild instanceof BondSide)) {
            final AbstractAgent abstractAgentRightSide = ((BondSide) rightBondSideOrWild).getAbstractAgent();
            if (((abstractAgentRightSide instanceof Agent) && 
              (!this.bindingIsTheSameRightAsLeft(agentInstance, siteInstance, lhs, rhs)))) {
              return false;
            }
          } else {
            final Wildcard wildcard = rightBondSideOrWild.getWildcard();
            if ((wildcard != null)) {
              boolean _isNothing = wildcard.isNothing();
              if (_isNothing) {
                boolean _contains_1 = agentsLeftSide.contains(agentInstance);
                if (_contains_1) {
                  if ((siteInstance == null)) {
                    final List<AgentInstance> freeAgentsLeftSide = this.getFreeAgentsInPattern(lhs);
                    boolean _contains_2 = freeAgentsLeftSide.contains(agentInstance);
                    boolean _not_2 = (!_contains_2);
                    if (_not_2) {
                      return false;
                    }
                  } else {
                    boolean _agentAndSiteWereConcreteOnLeftSide = this.agentAndSiteWereConcreteOnLeftSide(agentInstance, siteInstance, lhs);
                    boolean _not_3 = (!_agentAndSiteWereConcreteOnLeftSide);
                    if (_not_3) {
                      return false;
                    }
                  }
                }
              }
            }
            boolean _isAnything = wildcard.isAnything();
            if (_isAnything) {
              if ((siteInstance == null)) {
                return false;
              } else {
                boolean _bindingIsTheSameRightAsLeft = this.bindingIsTheSameRightAsLeft(agentInstance, siteInstance, lhs, rhs);
                boolean _not_4 = (!_bindingIsTheSameRightAsLeft);
                if (_not_4) {
                  return false;
                }
              }
            }
          }
        }
      }
    }
    return true;
  }
  
  private AgentInstance getAgentInstanceFromPattern(final Pattern pattern, final String name) {
    List<AgentInstance> _agentsSpecifiedInPattern = this.getAgentsSpecifiedInPattern(pattern);
    for (final AgentInstance ini : _agentsSpecifiedInPattern) {
      boolean _equals = ini.getName().equals(name);
      if (_equals) {
        return ini;
      }
    }
    return null;
  }
  
  private List<AgentInstance> getFreeAgentsInPattern(final Pattern pattern) {
    if ((pattern instanceof BlankPattern)) {
      return new ArrayList<AgentInstance>();
    } else {
      ArrayList<AgentInstance> freeAgentsLeftSide = new ArrayList<AgentInstance>();
      EList<Bond> _bonds = ((Bonds) pattern).getBonds();
      for (final Bond bond : _bonds) {
        BondSideOrWildcard _right = bond.getRight();
        boolean _tripleNotEquals = (_right != null);
        if (_tripleNotEquals) {
          final BondSideOrWildcard rightSide = bond.getRight();
          final BondSide leftSide = bond.getLeft();
          Wildcard _wildcard = rightSide.getWildcard();
          boolean _tripleNotEquals_1 = (_wildcard != null);
          if (_tripleNotEquals_1) {
            final AbstractAgent abstractAgentLeft = ((BondSide) leftSide).getAbstractAgent();
            if (((abstractAgentLeft instanceof AgentInstance) && rightSide.getWildcard().isNothing())) {
              freeAgentsLeftSide.add(((AgentInstance) abstractAgentLeft));
            }
          }
        }
      }
      return freeAgentsLeftSide;
    }
  }
  
  private boolean unOrUnderspecifiedInPattern(final AgentInstance ai, final Pattern lhs) {
    if ((lhs instanceof BlankPattern)) {
      return false;
    }
    EList<Bond> _bonds = ((Bonds) lhs).getBonds();
    for (final Bond bond : _bonds) {
      {
        AbstractAgent _abstractAgent = bond.getLeft().getAbstractAgent();
        final AgentInstance agentInstanceBond = ((AgentInstance) _abstractAgent);
        String _name = agentInstanceBond.getName();
        String _name_1 = ai.getName();
        boolean _equals = Objects.equal(_name, _name_1);
        if (_equals) {
          BondSideOrWildcard _right = bond.getRight();
          boolean _tripleEquals = (_right == null);
          if (_tripleEquals) {
            return true;
          }
        }
      }
    }
    return false;
  }
  
  private boolean unOrUnderspecifiedInPattern(final AgentInstance ai, final SiteInstance si, final Pattern lhs) {
    if ((lhs instanceof BlankPattern)) {
      return false;
    }
    EList<Bond> _bonds = ((Bonds) lhs).getBonds();
    for (final Bond bond : _bonds) {
      {
        AbstractAgent _abstractAgent = bond.getLeft().getAbstractAgent();
        final AgentInstance agentInstanceBond = ((AgentInstance) _abstractAgent);
        final SiteInstance siteInstanceBond = bond.getLeft().getSiteInstance();
        if (((siteInstanceBond != null) && Objects.equal(agentInstanceBond.getName(), ai.getName()))) {
          String _name = siteInstanceBond.getSite().getName();
          String _name_1 = si.getSite().getName();
          boolean _equals = Objects.equal(_name, _name_1);
          if (_equals) {
            final BondSideOrWildcard bondRightSideOrWildcard = bond.getRight();
            if ((bondRightSideOrWildcard == null)) {
              return true;
            } else {
              if (((bondRightSideOrWildcard.getWildcard() != null) && bondRightSideOrWildcard.getWildcard().isAnything())) {
                return true;
              }
            }
          }
        }
      }
    }
    return false;
  }
  
  private boolean agentAndSiteWereConcreteOnLeftSide(final AgentInstance ai, final SiteInstance si, final Pattern pattern) {
    if ((pattern instanceof BlankPattern)) {
      return true;
    }
    EList<Bond> _bonds = ((Bonds) pattern).getBonds();
    for (final Bond bond : _bonds) {
      {
        final BondSide leftBondSide = bond.getLeft();
        final BondSideOrWildcard rightBondSideOrWild = bond.getRight();
        AbstractAgent _abstractAgent = leftBondSide.getAbstractAgent();
        final AgentInstance leftAgent = ((AgentInstance) _abstractAgent);
        final SiteInstance leftSiteInstance = leftBondSide.getSiteInstance();
        if ((((leftSiteInstance != null) && Objects.equal(leftAgent.getName(), ai.getName())) && Objects.equal(leftSiteInstance.getSite().getName(), si.getSite().getName()))) {
          final Wildcard wildcard = rightBondSideOrWild.getWildcard();
          if ((wildcard != null)) {
            boolean _isAnything = wildcard.isAnything();
            if (_isAnything) {
              return false;
            }
          } else {
            final BondSide rightBondSide = ((BondSide) rightBondSideOrWild);
            AbstractAgent _abstractAgent_1 = rightBondSide.getAbstractAgent();
            if ((_abstractAgent_1 instanceof AgentInstance)) {
              AbstractAgent _abstractAgent_2 = rightBondSide.getAbstractAgent();
              final AgentInstance rightAgentInstance = ((AgentInstance) _abstractAgent_2);
              final SiteInstance rightSiteInstance = rightBondSide.getSiteInstance();
              if ((rightSiteInstance != null)) {
                if ((Objects.equal(rightAgentInstance.getName(), ai.getName()) && Objects.equal(rightSiteInstance.getSite().getName(), si.getSite().getName()))) {
                  return true;
                }
              }
            }
          }
          return true;
        } else {
          if (((rightBondSideOrWild != null) && (rightBondSideOrWild.getWildcard() == null))) {
            final BondSide rightBondSide_1 = ((BondSide) rightBondSideOrWild);
            AbstractAgent _abstractAgent_3 = rightBondSide_1.getAbstractAgent();
            if ((_abstractAgent_3 instanceof Agent)) {
              return false;
            } else {
              AbstractAgent _abstractAgent_4 = rightBondSide_1.getAbstractAgent();
              final AgentInstance rightAgentInstance_1 = ((AgentInstance) _abstractAgent_4);
              final SiteInstance rightSiteInstance_1 = rightBondSide_1.getSiteInstance();
              if ((rightSiteInstance_1 != null)) {
                if ((Objects.equal(rightAgentInstance_1.getName(), ai.getName()) && Objects.equal(rightSiteInstance_1.getSite().getName(), si.getSite().getName()))) {
                  return true;
                }
              }
            }
          }
        }
      }
    }
    return false;
  }
  
  private boolean bindingIsTheSameRightAsLeftWithoutState(final AgentInstance ai, final SiteInstance si, final Pattern left, final Pattern right) {
    if (((((ai == null) || (si == null)) || (left instanceof BlankPattern)) || (right instanceof BlankPattern))) {
      return false;
    }
    final EList<Bond> bondsLeft = ((Bonds) left).getBonds();
    final EList<Bond> bondsRight = ((Bonds) right).getBonds();
    for (final Bond bond : bondsLeft) {
      {
        final BondSide leftBondSide = bond.getLeft();
        AbstractAgent _abstractAgent = leftBondSide.getAbstractAgent();
        final AgentInstance leftAi = ((AgentInstance) _abstractAgent);
        boolean _equals = leftAi.getName().equals(ai.getName());
        if (_equals) {
          final SiteInstance leftSi = leftBondSide.getSiteInstance();
          if ((leftSi != null)) {
            boolean _equals_1 = leftSi.getSite().getName().equals(si.getSite().getName());
            if (_equals_1) {
              final BondType bondTypeLeft = bond.getBondType();
              final BondSideOrWildcard boundToLeft = bond.getRight();
              for (final Bond bondRight : bondsRight) {
                {
                  final BondSide rightPatternLeftBondSide = bondRight.getLeft();
                  AbstractAgent _abstractAgent_1 = rightPatternLeftBondSide.getAbstractAgent();
                  final AgentInstance rightPatternLeftBondAgentInstance = ((AgentInstance) _abstractAgent_1);
                  boolean _equals_2 = rightPatternLeftBondAgentInstance.getName().equals(ai.getName());
                  if (_equals_2) {
                    final SiteInstance rightPatternLeftSiteInstance = rightPatternLeftBondSide.getSiteInstance();
                    if (((rightPatternLeftSiteInstance != null) && 
                      rightPatternLeftSiteInstance.getSite().getName().equals(si.getSite().getName()))) {
                      final BondType bondTypeRight = bondRight.getBondType();
                      final BondSideOrWildcard boundToRight = bondRight.getRight();
                      boolean _equals_3 = Objects.equal(bondTypeLeft, bondTypeRight);
                      if (_equals_3) {
                        if (((boundToLeft == null) && (boundToRight == null))) {
                          return true;
                        } else {
                          if (((boundToLeft instanceof BondSide) && 
                            (boundToRight instanceof BondSide))) {
                            final AbstractAgent boundToLeftAbstractAgent = ((BondSide) boundToLeft).getAbstractAgent();
                            final AbstractAgent boundToRightAbstractAgent = ((BondSide) boundToRight).getAbstractAgent();
                            if (((boundToLeftAbstractAgent instanceof Agent) && 
                              (boundToRightAbstractAgent instanceof Agent))) {
                              final Agent boundToLeftAgent = ((Agent) boundToLeftAbstractAgent);
                              final Agent boundToRightAgent = ((Agent) boundToRightAbstractAgent);
                              String _name = boundToLeftAgent.getName();
                              String _name_1 = boundToRightAgent.getName();
                              boolean _equals_4 = Objects.equal(_name, _name_1);
                              if (_equals_4) {
                                final SiteInstance boundToLeftSiteInstance = ((BondSide) boundToLeft).getSiteInstance();
                                final SiteInstance boundToRightSiteInstance = ((BondSide) boundToRight).getSiteInstance();
                                if (((boundToLeftSiteInstance != null) && 
                                  (boundToRightSiteInstance != null))) {
                                  String _name_2 = boundToLeftSiteInstance.getSite().getName();
                                  String _name_3 = boundToRightSiteInstance.getSite().getName();
                                  boolean _equals_5 = Objects.equal(_name_2, _name_3);
                                  if (_equals_5) {
                                    return true;
                                  }
                                } else {
                                  if (((boundToLeftSiteInstance == null) && 
                                    (boundToRightSiteInstance == null))) {
                                    return true;
                                  } else {
                                    return false;
                                  }
                                }
                              }
                            }
                          }
                        }
                        if (((boundToLeft instanceof BondSideOrWildcard) && 
                          (boundToRight instanceof BondSideOrWildcard))) {
                          final Wildcard wildcardLeft = ((BondSideOrWildcard) boundToLeft).getWildcard();
                          final Wildcard wildcardRight = ((BondSideOrWildcard) boundToRight).getWildcard();
                          if (((wildcardLeft != null) && (wildcardRight != null))) {
                            if (((wildcardLeft.isNothing() && wildcardRight.isNothing()) || (wildcardLeft.isAnything() && wildcardRight.isAnything()))) {
                              return true;
                            }
                          }
                        }
                      }
                    }
                    return false;
                  }
                }
              }
            }
          }
        }
      }
    }
    return false;
  }
  
  private boolean bindingIsTheSameRightAsLeft(final AgentInstance ai, final SiteInstance si, final Pattern left, final Pattern right) {
    if (((((ai == null) || (si == null)) || (left instanceof BlankPattern)) || (right instanceof BlankPattern))) {
      return false;
    }
    final EList<Bond> bondsLeft = ((Bonds) left).getBonds();
    final EList<Bond> bondsRight = ((Bonds) right).getBonds();
    for (final Bond bond : bondsLeft) {
      {
        final BondSide leftBondSide = bond.getLeft();
        AbstractAgent _abstractAgent = leftBondSide.getAbstractAgent();
        final AgentInstance leftAi = ((AgentInstance) _abstractAgent);
        boolean _equals = leftAi.getName().equals(ai.getName());
        if (_equals) {
          final SiteInstance leftSi = leftBondSide.getSiteInstance();
          if ((leftSi != null)) {
            boolean _equals_1 = leftSi.getSite().getName().equals(si.getSite().getName());
            if (_equals_1) {
              final BondType bondTypeLeft = bond.getBondType();
              final BondSideOrWildcard boundToLeft = bond.getRight();
              for (final Bond bondRight : bondsRight) {
                {
                  final BondSide rightPatternLeftBondSide = bondRight.getLeft();
                  AbstractAgent _abstractAgent_1 = rightPatternLeftBondSide.getAbstractAgent();
                  final AgentInstance rightPatternLeftBondAgentInstance = ((AgentInstance) _abstractAgent_1);
                  boolean _equals_2 = rightPatternLeftBondAgentInstance.getName().equals(ai.getName());
                  if (_equals_2) {
                    final SiteInstance rightPatternLeftSiteInstance = rightPatternLeftBondSide.getSiteInstance();
                    if (((rightPatternLeftSiteInstance != null) && 
                      rightPatternLeftSiteInstance.getSite().getName().equals(si.getSite().getName()))) {
                      final BondType bondTypeRight = bondRight.getBondType();
                      final BondSideOrWildcard boundToRight = bondRight.getRight();
                      boolean _equals_3 = Objects.equal(bondTypeLeft, bondTypeRight);
                      if (_equals_3) {
                        if (((boundToLeft instanceof BondSide) && (boundToRight instanceof BondSide))) {
                          final AbstractAgent boundToLeftAbstractAgent = ((BondSide) boundToLeft).getAbstractAgent();
                          final AbstractAgent boundToRightAbstractAgent = ((BondSide) boundToRight).getAbstractAgent();
                          if (((boundToLeftAbstractAgent instanceof Agent) && 
                            (boundToRightAbstractAgent instanceof Agent))) {
                            final Agent boundToLeftAgent = ((Agent) boundToLeftAbstractAgent);
                            final Agent boundToRightAgent = ((Agent) boundToRightAbstractAgent);
                            String _name = boundToLeftAgent.getName();
                            String _name_1 = boundToRightAgent.getName();
                            boolean _equals_4 = Objects.equal(_name, _name_1);
                            if (_equals_4) {
                              final SiteInstance boundToLeftSiteInstance = ((BondSide) boundToLeft).getSiteInstance();
                              final SiteInstance boundToRightSiteInstance = ((BondSide) boundToRight).getSiteInstance();
                              if (((boundToLeftSiteInstance != null) && 
                                (boundToRightSiteInstance != null))) {
                                String _name_2 = boundToLeftSiteInstance.getSite().getName();
                                String _name_3 = boundToRightSiteInstance.getSite().getName();
                                boolean _equals_5 = Objects.equal(_name_2, _name_3);
                                if (_equals_5) {
                                  final SiteInstanceState boundToLeftState = boundToLeftSiteInstance.getSiteState();
                                  final SiteInstanceState boundToRightState = boundToRightSiteInstance.getSiteState();
                                  if (((boundToLeftState != null) && 
                                    (boundToRightState != null))) {
                                    String _name_4 = boundToLeftState.getState().getName();
                                    String _name_5 = boundToRightState.getState().getName();
                                    boolean _equals_6 = Objects.equal(_name_4, _name_5);
                                    if (_equals_6) {
                                      return true;
                                    }
                                  } else {
                                    if (((boundToLeftState == null) && 
                                      (boundToRightState == null))) {
                                      return true;
                                    } else {
                                      return false;
                                    }
                                  }
                                }
                              } else {
                                if (((boundToLeftSiteInstance == null) && 
                                  (boundToRightSiteInstance == null))) {
                                  return true;
                                } else {
                                  return false;
                                }
                              }
                            }
                          }
                        }
                        if (((boundToLeft instanceof BondSideOrWildcard) && 
                          (boundToRight instanceof BondSideOrWildcard))) {
                          final Wildcard wildcardLeft = ((BondSideOrWildcard) boundToLeft).getWildcard();
                          final Wildcard wildcardRight = ((BondSideOrWildcard) boundToRight).getWildcard();
                          if (((wildcardLeft != null) && (wildcardRight != null))) {
                            if (((wildcardLeft.isNothing() && wildcardRight.isNothing()) || (wildcardLeft.isAnything() && wildcardRight.isAnything()))) {
                              return true;
                            }
                          }
                        }
                      }
                    }
                    return false;
                  }
                }
              }
            }
          }
        }
      }
    }
    return false;
  }
  
  private boolean siteWasBoundToGeneric(final SiteInstance si, final Pattern lhs) {
    if ((lhs instanceof BlankPattern)) {
      return false;
    } else {
      final EList<Bond> bonds = ((Bonds) lhs).getBonds();
      for (final Bond bond : bonds) {
        {
          final SiteInstance leftSiteInstance = bond.getLeft().getSiteInstance();
          if ((leftSiteInstance != null)) {
            final BondSideOrWildcard rightBondSideOrWild = bond.getRight();
            if ((rightBondSideOrWild instanceof BondSide)) {
              final BondSide rightBondSide = ((BondSide) rightBondSideOrWild);
              final AbstractAgent abstractAgent = rightBondSide.getAbstractAgent();
              if ((Objects.equal(leftSiteInstance.getSite(), si.getSite()) && (abstractAgent instanceof Agent))) {
                return true;
              }
            }
          }
        }
      }
      return false;
    }
  }
  
  private List<AgentInstance> getAgentsSpecifiedInPattern(final Pattern pattern) {
    if ((pattern instanceof BlankPattern)) {
      return new ArrayList<AgentInstance>();
    } else {
      ArrayList<AgentInstance> specifiedAgentsSide = new ArrayList<AgentInstance>();
      EList<Bond> _bonds = ((Bonds) pattern).getBonds();
      for (final Bond bond : _bonds) {
        {
          final AbstractAgent abstractAgent = bond.getLeft().getAbstractAgent();
          if ((abstractAgent instanceof AgentInstance)) {
            final AgentInstance agentInstance = ((AgentInstance) abstractAgent);
            boolean _contains = specifiedAgentsSide.contains(agentInstance);
            boolean _not = (!_contains);
            if (_not) {
              specifiedAgentsSide.add(agentInstance);
            }
          }
          BondSideOrWildcard _right = bond.getRight();
          boolean _tripleNotEquals = (_right != null);
          if (_tripleNotEquals) {
            final BondSideOrWildcard rightSide = bond.getRight();
            Wildcard _wildcard = rightSide.getWildcard();
            boolean _tripleEquals = (_wildcard == null);
            if (_tripleEquals) {
              final AbstractAgent abstractAgentRight = ((BondSide) rightSide).getAbstractAgent();
              if ((abstractAgentRight instanceof AgentInstance)) {
                final AgentInstance agentInstanceRight = ((AgentInstance) abstractAgentRight);
                boolean _contains_1 = specifiedAgentsSide.contains(agentInstanceRight);
                boolean _not_1 = (!_contains_1);
                if (_not_1) {
                  specifiedAgentsSide.add(agentInstanceRight);
                }
              }
            }
          }
        }
      }
      return specifiedAgentsSide;
    }
  }
  
  @Check
  public void checkNoGenericsOnLeftBondSide(final Bonds bonds) {
    EList<Bond> _bonds = bonds.getBonds();
    for (final Bond bond : _bonds) {
      AbstractAgent _abstractAgent = bond.getLeft().getAbstractAgent();
      if ((_abstractAgent instanceof Agent)) {
        this.error("No generic Agents on left side of bond allowed", bond.getLeft(), 
          ReactionLanguagePackage.Literals.BOND_SIDE__ABSTRACT_AGENT);
      }
    }
  }
  
  @Check
  public void checkNoUnderspecifiedStateChanges(final Rule rule) {
    final Pattern patternLeft = rule.getBody().getLhs();
    final Pattern patternRight = rule.getBody().getRhs();
    List<AgentInstance> specifiedAgentsLeftSide = this.getAgentsSpecifiedInPattern(patternLeft);
    if ((!((patternLeft instanceof BlankPattern) || (patternRight instanceof BlankPattern)))) {
      final Bonds bondsLeft = ((Bonds) patternLeft);
      final Bonds bondsRight = ((Bonds) patternRight);
      ArrayList<SiteInstance> sitesInStateLeft = new ArrayList<SiteInstance>();
      EList<Bond> _bonds = bondsLeft.getBonds();
      for (final Bond bond : _bonds) {
        {
          final SiteInstance siteInstance = bond.getLeft().getSiteInstance();
          if (((siteInstance != null) && (siteInstance.getSiteState() != null))) {
            sitesInStateLeft.add(siteInstance);
          }
        }
      }
      EList<Bond> _bonds_1 = bondsRight.getBonds();
      for (final Bond bond_1 : _bonds_1) {
        {
          final AbstractAgent abstractAgentLeft = bond_1.getLeft().getAbstractAgent();
          if ((abstractAgentLeft instanceof AgentInstance)) {
            AgentInstance agentInstanceLeft = ((AgentInstance) abstractAgentLeft);
            boolean _contains = specifiedAgentsLeftSide.contains(agentInstanceLeft);
            boolean _not = (!_contains);
            if (_not) {
            } else {
              final SiteInstance siteInstanceLeft = bond_1.getLeft().getSiteInstance();
              if ((siteInstanceLeft != null)) {
                final SiteInstanceState siteState = siteInstanceLeft.getSiteState();
                if (((siteState != null) && 
                  (!this.isSiteStateSpecifiedInPattern(agentInstanceLeft, siteInstanceLeft, patternLeft)))) {
                  this.error("Underspecified state change", siteInstanceLeft, 
                    ReactionLanguagePackage.Literals.SITE_INSTANCE__SITE_STATE);
                }
              }
              final BondSideOrWildcard bondRight = bond_1.getRight();
              if (((bondRight != null) && (bondRight.getWildcard() == null))) {
                BondSideOrWildcard _right = bond_1.getRight();
                final BondSide bondSideRight = ((BondSide) _right);
                final AbstractAgent abstractAgentRight = bondSideRight.getAbstractAgent();
                if ((abstractAgentRight instanceof AgentInstance)) {
                  final AgentInstance agentInstanceRight = ((AgentInstance) abstractAgentRight);
                  boolean _contains_1 = specifiedAgentsLeftSide.contains(agentInstanceRight);
                  boolean _not_1 = (!_contains_1);
                  if (_not_1) {
                  } else {
                    final SiteInstance siteInstanceRight = bondSideRight.getSiteInstance();
                    if ((siteInstanceRight != null)) {
                      final SiteInstanceState siteState_1 = siteInstanceRight.getSiteState();
                      if (((siteState_1 != null) && 
                        (!this.isSiteStateSpecifiedInPattern(agentInstanceRight, siteInstanceRight, patternLeft)))) {
                        this.error("Underspecified state change", siteInstanceRight, 
                          ReactionLanguagePackage.Literals.SITE_INSTANCE__SITE_STATE);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  private boolean isSiteSpecifiedInPattern(final AgentInstance ai, final SiteInstance si, final Pattern pattern) {
    if ((pattern instanceof BlankPattern)) {
      return false;
    } else {
      final Bonds bonds = ((Bonds) pattern);
      EList<Bond> _bonds = bonds.getBonds();
      for (final Bond bond : _bonds) {
        {
          final AbstractAgent leftAbstract = bond.getLeft().getAbstractAgent();
          if ((leftAbstract instanceof AgentInstance)) {
            final AgentInstance leftAi = ((AgentInstance) leftAbstract);
            final SiteInstance leftSi = bond.getLeft().getSiteInstance();
            if ((leftSi != null)) {
              if ((Objects.equal(leftAi.getName(), ai.getName()) && Objects.equal(leftSi.getSite().getName(), si.getSite().getName()))) {
                return true;
              }
            }
          }
          BondSideOrWildcard _right = bond.getRight();
          if ((_right instanceof BondSide)) {
            BondSideOrWildcard _right_1 = bond.getRight();
            final BondSide rightBondSide = ((BondSide) _right_1);
            final AbstractAgent rightAbstract = rightBondSide.getAbstractAgent();
            if ((rightAbstract instanceof AgentInstance)) {
              final AgentInstance rightAi = ((AgentInstance) rightAbstract);
              final SiteInstance rightSi = rightBondSide.getSiteInstance();
              if ((rightSi != null)) {
                if ((Objects.equal(rightAi.getName(), ai.getName()) && Objects.equal(rightSi.getSite().getName(), si.getSite().getName()))) {
                  return true;
                }
              }
            }
          }
        }
      }
    }
    return false;
  }
  
  private boolean isSiteStateSpecifiedInPattern(final AgentInstance ai, final SiteInstance si, final Pattern pattern) {
    if ((pattern instanceof BlankPattern)) {
      return false;
    } else {
      final Bonds bonds = ((Bonds) pattern);
      EList<Bond> _bonds = bonds.getBonds();
      for (final Bond bond : _bonds) {
        {
          final AbstractAgent leftAbstract = bond.getLeft().getAbstractAgent();
          if ((leftAbstract instanceof AgentInstance)) {
            final AgentInstance leftAi = ((AgentInstance) leftAbstract);
            final SiteInstance leftSi = bond.getLeft().getSiteInstance();
            if ((leftSi != null)) {
              final SiteInstanceState leftState = leftSi.getSiteState();
              if ((((leftState != null) && Objects.equal(leftAi.getName(), ai.getName())) && Objects.equal(leftSi.getSite().getName(), si.getSite().getName()))) {
                return true;
              }
            }
          }
          BondSideOrWildcard _right = bond.getRight();
          if ((_right instanceof BondSide)) {
            BondSideOrWildcard _right_1 = bond.getRight();
            final BondSide rightBondSide = ((BondSide) _right_1);
            final AbstractAgent rightAbstract = rightBondSide.getAbstractAgent();
            if ((rightAbstract instanceof AgentInstance)) {
              final AgentInstance rightAi = ((AgentInstance) rightAbstract);
              final SiteInstance rightSi = rightBondSide.getSiteInstance();
              if ((rightSi != null)) {
                final SiteInstanceState rightState = rightSi.getSiteState();
                if ((((rightState != null) && Objects.equal(rightAi.getName(), ai.getName())) && Objects.equal(rightSi.getSite().getName(), si.getSite().getName()))) {
                  return true;
                }
              }
            }
          }
        }
      }
    }
    return false;
  }
  
  @Check
  public void checkSiteIsNotNull(final Bond bond) {
    final BondSide leftSide = bond.getLeft();
    final BondSideOrWildcard rightSide = bond.getRight();
    final BondType bondType = bond.getBondType();
    if ((rightSide == null)) {
      return;
    }
    if ((Objects.equal(bondType, BondType.UNBOUND) && (rightSide.getWildcard() != null))) {
      return;
    }
    SiteInstance _siteInstance = leftSide.getSiteInstance();
    boolean _tripleEquals = (_siteInstance == null);
    if (_tripleEquals) {
      this.error("Site is missing", bond, ReactionLanguagePackage.Literals.BOND__LEFT);
    }
  }
  
  @Check
  public void checkNoMultipleUnderspecifiedBindingsOnLeftSide(final Rule rule) {
    final Pattern leftSide = rule.getBody().getLhs();
    if ((!(leftSide instanceof BlankPattern))) {
      final Bonds leftBonds = ((Bonds) leftSide);
      boolean oneUnderspecifiedBinding = false;
      EList<Bond> _bonds = leftBonds.getBonds();
      for (final Bond bond : _bonds) {
        BondSideOrWildcard _right = bond.getRight();
        boolean _tripleNotEquals = (_right != null);
        if (_tripleNotEquals) {
          final Wildcard wildcard = bond.getRight().getWildcard();
          final SiteInstance siteInstance = bond.getLeft().getSiteInstance();
          if ((((siteInstance == null) && (wildcard != null)) && wildcard.isAnything())) {
            this.error("Only one underspecified binding on left side allowed", bond, 
              ReactionLanguagePackage.Literals.BOND__LEFT);
          }
          if (((wildcard != null) && wildcard.isAnything())) {
            if (oneUnderspecifiedBinding) {
              this.error("Only one underspecified binding on left side allowed", bond, 
                ReactionLanguagePackage.Literals.BOND__RIGHT);
            } else {
              oneUnderspecifiedBinding = true;
            }
          }
        }
      }
    }
  }
  
  private void checkNoArithmeticLoops(final Variable aVar, final List<Variable> collectedVars) {
    boolean _contains = collectedVars.contains(aVar);
    if (_contains) {
      this.error("Reference loop!", ReactionLanguagePackage.Literals.VARIABLE__VALUE);
    } else {
      final List<VarRef> referencedVars = EcoreUtil2.<VarRef>getAllContentsOfType(aVar, VarRef.class);
      collectedVars.add(aVar);
      for (final VarRef referencedVar : referencedVars) {
        Variable _ref = referencedVar.getRef();
        if ((_ref instanceof Variable)) {
          Variable _ref_1 = referencedVar.getRef();
          this.checkNoArithmeticLoops(((Variable) _ref_1), collectedVars);
        }
      }
    }
  }
  
  @Check
  public void checkForUnusedAgentInstances(final Signature signature) {
    EObject _eContainer = signature.eContainer();
    boolean _not = (!(_eContainer instanceof ObservablePattern));
    if (_not) {
      final EList<AgentInstance> agentInstances = signature.getInstances();
      EObject contentToSearch = ((EObject) null);
      EObject _eContainer_1 = signature.eContainer();
      if ((_eContainer_1 instanceof RuleHead)) {
        final EObject head = signature.eContainer();
        EObject _eContainer_2 = head.eContainer();
        RuleBody _body = ((Rule) _eContainer_2).getBody();
        contentToSearch = ((RuleBody) _body);
      }
      EObject _eContainer_3 = signature.eContainer();
      if ((_eContainer_3 instanceof Complex)) {
        EObject _eContainer_4 = signature.eContainer();
        contentToSearch = ((Complex) _eContainer_4);
      }
      EObject _eContainer_5 = signature.eContainer();
      if ((_eContainer_5 instanceof InitialisationBody)) {
        EObject _eContainer_6 = signature.eContainer();
        contentToSearch = ((InitialisationBody) _eContainer_6);
      }
      EObject _eContainer_7 = signature.eContainer();
      if ((_eContainer_7 instanceof Observable)) {
        EObject _eContainer_8 = signature.eContainer();
        contentToSearch = ((Observable) _eContainer_8);
      }
      EObject _eContainer_9 = signature.eContainer();
      if ((_eContainer_9 instanceof TerminateCount)) {
        EObject _eContainer_10 = signature.eContainer();
        contentToSearch = ((TerminateCount) _eContainer_10);
      }
      for (final AgentInstance agentInstance : agentInstances) {
        boolean _isEmpty = EcoreUtil.UsageCrossReferencer.find(agentInstance, contentToSearch).isEmpty();
        if (_isEmpty) {
          String _name = agentInstance.getName();
          String _plus = ("Agent instance " + _name);
          String _plus_1 = (_plus + " is not used");
          this.warning(_plus_1, agentInstance, 
            this.getNameFeature(agentInstance));
        }
      }
    }
  }
  
  @Check
  public void checkRuleSignatureExists(final Rule rule) {
    final Signature signature = rule.getHead().getSignature();
    if (((signature == null) && (!this.isObjectInComplex(rule)))) {
      this.error("Signature needed when using patterns", ReactionLanguagePackage.Literals.RULE__BODY);
    }
  }
  
  private boolean isObjectInComplex(final EObject obj) {
    EObject containerTraverser = obj;
    while ((!(containerTraverser instanceof Complex))) {
      {
        if ((containerTraverser instanceof ReactionModel)) {
          return false;
        }
        containerTraverser = containerTraverser.eContainer();
      }
    }
    return true;
  }
  
  @Check
  public void checkTerminateSignatureExists(final TerminateCount tCount) {
    final Signature signature = tCount.getSignature();
    if ((signature == null)) {
      this.error("Signature needed when using patterns.", ReactionLanguagePackage.Literals.TERMINATE_COUNT__PATTERN);
    }
  }
  
  @Check
  public void checkNestedUniqueAgentInstanceNames(final AgentInstance aInstance) {
    EObject _eContainer = aInstance.eContainer();
    if ((_eContainer instanceof Signature)) {
      ArrayList<AgentInstance> aInstancesInSignatures = Lists.<AgentInstance>newArrayList();
      EObject containerTraverser = aInstance.eContainer();
      while ((!(containerTraverser instanceof ReactionModel))) {
        {
          if ((containerTraverser instanceof Signature)) {
            aInstancesInSignatures.addAll(((Signature) containerTraverser).getInstances());
          }
          if ((containerTraverser instanceof Complex)) {
            aInstancesInSignatures.addAll(((Complex) containerTraverser).getSignature().getInstances());
          }
          containerTraverser = containerTraverser.eContainer();
        }
      }
      for (final AgentInstance otherAInstance : aInstancesInSignatures) {
        if (((aInstance != otherAInstance) && Objects.equal(aInstance.getName(), otherAInstance.getName()))) {
          final EStructuralFeature nameFeature = this.getNameFeature(aInstance);
          String _name = aInstance.getName();
          String _plus = ("Duplicate AgentInstance " + _name);
          this.error(_plus, aInstance, nameFeature);
          String _name_1 = aInstance.getName();
          String _plus_1 = ("Duplicate AgentInstance " + _name_1);
          this.error(_plus_1, otherAInstance, nameFeature);
        }
      }
    }
  }
  
  private EStructuralFeature getNameFeature(final EObject object) {
    return SimpleAttributeResolver.NAME_RESOLVER.getAttribute(object);
  }
  
  @Check
  public void checkSecondRateExits(final Rates rates) {
    EObject containerTraverser = rates.eContainer();
    Rule rule = ((Rule) null);
    while ((!(containerTraverser instanceof Rule))) {
      containerTraverser = containerTraverser.eContainer();
    }
    if ((containerTraverser instanceof Rule)) {
      rule = ((Rule)containerTraverser);
    }
    final RuleType ruleType = rule.getBody().getRuleType();
    if ((Objects.equal(ruleType, RuleType.BI) && (!rates.isRateBackwardSet()))) {
      this.error("Rates for bidirectional rule are not complete. Maybe you forgot the rate for the backwards rule?", 
        ReactionLanguagePackage.Literals.RATES__RATE_FORWARD);
    }
    if ((Objects.equal(ruleType, RuleType.UNI) && rates.isRateBackwardSet())) {
      this.error("For unidirectional rules only one rate is allowed", 
        ReactionLanguagePackage.Literals.RATES__RATE_BACKWARD);
    }
  }
  
  @Check
  public void checkArrayInstancesRightBondSide(final BondSide bondSide) {
    final AbstractAgent abstractAgent = bondSide.getAbstractAgent();
    if ((abstractAgent instanceof AgentInstance)) {
      final AgentInstance aInstance = ((AgentInstance) abstractAgent);
      if ((bondSide.isArray() && aInstance.isArray())) {
        int _index = bondSide.getIndex();
        int _size = aInstance.getSize();
        boolean _greaterEqualsThan = (_index >= _size);
        if (_greaterEqualsThan) {
          this.error("Index out of range", ReactionLanguagePackage.Literals.BOND_SIDE__INDEX);
        }
      }
      if (((!bondSide.isArray()) && aInstance.isArray())) {
        this.warning("Array access without index", ReactionLanguagePackage.Literals.BOND_SIDE__ABSTRACT_AGENT);
      }
      if ((bondSide.isArray() && (!aInstance.isArray()))) {
        this.error("Cannot access simple agents as array", 
          ReactionLanguagePackage.Literals.BOND_SIDE__ABSTRACT_AGENT);
      }
    }
    if ((abstractAgent instanceof Agent)) {
      boolean _isArray = bondSide.isArray();
      if (_isArray) {
        this.error("Generic arrays are not allowed", ReactionLanguagePackage.Literals.BOND_SIDE__ARRAY);
      }
    }
  }
  
  @Check
  public void checkComplexNotEmpty(final Complex complex) {
    boolean _isEmpty = complex.eContents().isEmpty();
    if (_isEmpty) {
      this.warning("Complex is empty", ReactionLanguagePackage.Literals.COMPLEX__ELEMENTS);
    }
  }
  
  private <T extends EObject> ArrayList<AgentInstance> getAllSignatureMembers(final T context) {
    Signature signature = ((Signature) null);
    EObject containerTraverser = context.eContainer();
    ArrayList<AgentInstance> candidates = new ArrayList<AgentInstance>();
    while ((!(containerTraverser instanceof ReactionModel))) {
      {
        containerTraverser = containerTraverser.eContainer();
        if ((containerTraverser instanceof Rule)) {
          signature = ((Rule)containerTraverser).getHead().getSignature();
        }
        if ((containerTraverser instanceof Complex)) {
          signature = ((Complex)containerTraverser).getSignature();
        }
        if ((containerTraverser instanceof InitialisationBody)) {
          signature = ((InitialisationBody)containerTraverser).getSignature();
        }
        if ((containerTraverser instanceof ObservablePattern)) {
          signature = ((ObservablePattern)containerTraverser).getSignature();
        }
        if ((containerTraverser instanceof TerminateCount)) {
          signature = ((TerminateCount)containerTraverser).getSignature();
        }
        if ((signature != null)) {
          candidates.addAll(signature.getInstances());
        }
      }
    }
    return candidates;
  }
  
  @Check
  public void checkInitialisationCnt(final InitialisationHead initHead) {
    final double cnt = this.calculator.evaluate(initHead.getCnt());
    if ((cnt < 0)) {
      this.error("Cannot initialize negative amount", ReactionLanguagePackage.Literals.INITIALISATION_HEAD__CNT);
    }
    if ((cnt == 0)) {
      this.warning("Initializing nothing", ReactionLanguagePackage.Literals.INITIALISATION_HEAD__CNT);
    }
    double _floor = Math.floor(cnt);
    boolean _notEquals = (cnt != _floor);
    if (_notEquals) {
      this.error("Can only initialise integer amounts", ReactionLanguagePackage.Literals.INITIALISATION_HEAD__CNT);
    }
  }
  
  @Check
  public void checkTerminate(final TerminateBody tBody) {
    if ((tBody instanceof TerminateIterations)) {
      final ArithmeticExpr cnt = ((TerminateIterations) tBody).getIterations();
      final double eval = this.calculator.evaluate(cnt);
      double _floor = Math.floor(eval);
      boolean _notEquals = (eval != _floor);
      if (_notEquals) {
        this.error("Can only execute whole iterations", 
          ReactionLanguagePackage.eINSTANCE.getTerminateIterations_Iterations());
      }
    }
    if ((tBody instanceof TerminateCount)) {
      final ArithmeticExpr cnt_1 = ((TerminateCount) tBody).getCnt();
      final double eval_1 = this.calculator.evaluate(cnt_1);
      double _floor_1 = Math.floor(eval_1);
      boolean _notEquals_1 = (eval_1 != _floor_1);
      if (_notEquals_1) {
        this.error("Can only match for integer amount", ReactionLanguagePackage.eINSTANCE.getTerminateCount_Cnt());
      }
    }
  }
  
  @Check
  public void checkDivideByZero(final Div div) {
    final double divisor = this.calculator.evaluate(div.getRight());
    if ((divisor == 0.0)) {
      this.error("Division by zero!", ReactionLanguagePackage.eINSTANCE.getDiv_Right());
    }
  }
  
  @Check
  public void checkNegativeSqrt(final FunctionCall fc) {
    if ((Objects.equal(fc.getFunc(), MathFunc.SQRT) && (this.calculator.evaluate(fc.getExpr()) < 0))) {
      this.error("Negative discriminant!", ReactionLanguagePackage.Literals.FUNCTION_CALL__EXPR);
    }
  }
  
  @Check
  public void checkNoNegativeRates(final Rates rates) {
    double _evaluate = this.calculator.evaluate(rates.getRateForward());
    boolean _lessThan = (_evaluate < 0);
    if (_lessThan) {
      this.error("No negative rates allowed", ReactionLanguagePackage.Literals.RATES__RATE_FORWARD);
    }
    double _evaluate_1 = this.calculator.evaluate(rates.getRateForward());
    boolean _equals = (_evaluate_1 == 0);
    if (_equals) {
      this.warning(
        "Reaction rate is zero", 
        ReactionLanguagePackage.Literals.RATES__RATE_FORWARD);
    }
    ArithmeticExpr _rateBackward = rates.getRateBackward();
    boolean _tripleNotEquals = (_rateBackward != null);
    if (_tripleNotEquals) {
      double _evaluate_2 = this.calculator.evaluate(rates.getRateBackward());
      boolean _lessThan_1 = (_evaluate_2 < 0);
      if (_lessThan_1) {
        this.error("No negative rates allowed", ReactionLanguagePackage.Literals.RATES__RATE_BACKWARD);
      }
      double _evaluate_3 = this.calculator.evaluate(rates.getRateBackward());
      boolean _equals_1 = (_evaluate_3 == 0);
      if (_equals_1) {
        this.warning("Reaction rate is zero", ReactionLanguagePackage.Literals.RATES__RATE_BACKWARD);
      }
    }
  }
}
