/*
 * generated by Xtext 2.20.0
 */
package org.reaction.dsl.formatting2

import com.google.inject.Inject
import org.eclipse.xtext.formatting2.AbstractFormatter2
import org.eclipse.xtext.formatting2.IFormattableDocument
import org.reaction.dsl.services.ReactionLanguageGrammarAccess
import org.reaction.dsl.reactionLanguage.*

class ReactionLanguageFormatter extends AbstractFormatter2 {

	@Inject extension ReactionLanguageGrammarAccess

	def dispatch void format(ReactionModel reactionModel, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		for (component : reactionModel.elements) {
			component.format
		}
	}

	def dispatch void format(Agent agent, extension IFormattableDocument document) {
		if (agent.sites !== null) {
			agent.regionFor.keyword(agentAccess.colonKeyword_1_0).append[oneSpace]
			agent.regionFor.keyword(agentAccess.commaKeyword_1_2_0).append[oneSpace]
		}

		for (site : agent.sites) {
			site.format
		}
	}

	def dispatch void format(AgentDeclaration decl, extension IFormattableDocument document) {
		decl.regionFor.keyword(agentDeclarationAccess.agentKeyword_0).append[oneSpace]
		if (decl.declaredAgents.size > 1) {
			decl.regionFor.keyword(agentDeclarationAccess.semicolonKeyword_2_0).append[oneSpace]
		}
		decl.regionFor.feature(ReactionLanguagePackage.Literals.AGENT_DECLARATION__DECLARED_AGENTS).append[newLine]
		for (Agent agent : decl.declaredAgents) {
			agent.format
		}
	}

	def dispatch void format(Site site, extension IFormattableDocument document) {
		if (site.states !== null) {
			if (site.states.size > 1) {
				site.regionFor.keyword(siteAccess.commaKeyword_1_2_0).append[oneSpace]
			}
			for (SiteState state : site.states) {
				state.format // Actually not needed since state only consists of its ID
			}
		}
		site.regionFor.keyword(siteAccess.commaKeyword_1_2_0).append[oneSpace]
	}

	def dispatch void format(Complex complex, extension IFormattableDocument document) {
		complex.regionFor.keyword(complexAccess.complexKeyword_0).prepend[newLine]
		complex.regionFor.keyword(complexAccess.leftCurlyBracketKeyword_2).append[newLine]
		complex.signature.format
		complex.interior[indent]
		for (ComplexElement cElem : complex.elements) {
			cElem.format
		}
		complex.regionFor.keyword(complexAccess.rightCurlyBracketKeyword_4).append[newLine]
	}

	def dispatch void format(Signature sig, extension IFormattableDocument document) {
		if (sig.instances.size > 1) {
			sig.regionFor.keyword(signatureAccess.commaKeyword_2_0).append[oneSpace]
		}
		for (AgentInstance ai : sig.instances) {
			ai.format
		}
	}

	def dispatch void format(AgentInstance ai, extension IFormattableDocument document) {
		ai.regionFor.keyword(agentInstanceAccess.colonKeyword_1).append[oneSpace]
	}

	def dispatch void format(Rule rule, extension IFormattableDocument document) {
		rule.regionFor.keyword(ruleAccess.ruleKeyword_0).append[oneSpace]
		rule.head.format
		rule.body.format
		rule.regionFor.feature(ReactionLanguagePackage.Literals.RULE__BODY).append[newLine]
	}

	def dispatch void format(RuleHead rHead, extension IFormattableDocument document) {
		rHead.regionFor.feature(ReactionLanguagePackage.Literals.RULE_HEAD__NAME).append[oneSpace]
		if (rHead.signature !== null) {
			rHead.signature.format
		}else{
			rHead.regionFor.feature(ReactionLanguagePackage.Literals.RULE_HEAD__SIGNATURE).surround[noSpace]	
		}
		rHead.regionFor.keyword(ruleHeadAccess.colonKeyword_2).prepend[noSpace]
	}

	def dispatch void format(RuleBody rBody, extension IFormattableDocument document) {
		
		val lhs = rBody.lhs
		val rhs = rBody.rhs
		if (!(lhs instanceof BlankPattern)) {
			lhs.format
		}
		if (!(rhs instanceof BlankPattern)) {
			rhs.format
		}
		rBody.rates.format
	}

	def dispatch void format(Rates rates, extension IFormattableDocument document) {
		if (rates.rateBackwardSet) {
			rates.regionFor.feature(ReactionLanguagePackage.Literals.RATES__RATE_BACKWARD_SET).append[oneSpace]
		}
	}

	def dispatch void format(Bonds bonds, extension IFormattableDocument document) {
		if (bonds.bonds.size > 1) {
			bonds.regionFor.keyword(bondsAccess.commaKeyword_1_0).append[oneSpace]
		}
	}

	def dispatch void format(Bond bond, extension IFormattableDocument document) {
		bond.left.format
		if (bond.right !== null) {
//			bond.bondType.format
			bond.right.format
		}
	}

	def dispatch void format(BondSideOrWildcard bondOrWild, extension IFormattableDocument document) {
		if (bondOrWild instanceof BondSide) {
			(bondOrWild as BondSide).format
		}
	}

	def dispatch void format(BondSide bSide, extension IFormattableDocument document) {
		if (bSide.siteInstance !== null) {
			bSide.siteInstance.format
		}
	}

	def dispatch void format(SiteInstance si, extension IFormattableDocument document) {
		if (si.siteState !== null) {
			si.siteState.format
		}
	}

	def dispatch void format(Variable variable, extension IFormattableDocument document) {
		variable.regionFor.keyword(variableAccess.equalsSignKeyword_2).surround[oneSpace]
		variable.value.format
	}

	def dispatch void format(Initialisation init, extension IFormattableDocument document) {
		init.head.format
		init.body.format.append[newLine]
	}

	def dispatch void format(InitialisationHead iHead, extension IFormattableDocument document) {
		iHead.cnt.format
	}

	def dispatch void format(InitialisationBody iBody, extension IFormattableDocument document) {
		if (iBody.signature !== null) {
			iBody.signature.format
		}
		iBody.regionFor.keyword(initialisationBodyAccess.colonKeyword_1).append[oneSpace]
		iBody.pattern.format
	}

	def dispatch void format(Observable obs, extension IFormattableDocument document) {
		obs.regionFor.keyword(observableAccess.observeKeyword_0).append[oneSpace]
		obs.regionFor.feature(ReactionLanguagePackage.Literals.OBSERVABLE__NAME).append[oneSpace]
		obs.body.format
	}

	def dispatch void format(ObservablePattern oBody, extension IFormattableDocument document) {
		if (oBody.signature !== null) {
			oBody.signature.format
		}
		oBody.regionFor.keyword(observablePatternAccess.colonKeyword_1).append[oneSpace]
		oBody.pattern.format
	}

	def dispatch void format(TerminateTime tTime, extension IFormattableDocument document) {
		tTime.regionFor.keyword(terminateTimeAccess.equalsSignKeyword_1).surround[oneSpace]
		tTime.time.format
	}

	def dispatch void format(TerminateIterations tIterations, extension IFormattableDocument document) {
		tIterations.regionFor.keyword(terminateIterationsAccess.equalsSignKeyword_1).surround[oneSpace]
		tIterations.iterations.format
	}

	def dispatch void format(TerminateCount tCount, extension IFormattableDocument document) {
		if (tCount.signature !== null) {
			tCount.signature.format
			tCount.regionFor.keyword(terminateCountAccess.colonKeyword_0_1).append[oneSpace]
		}
		tCount.pattern.format
		tCount.regionFor.keyword(terminateCountAccess.equalsSignKeyword_3).surround[oneSpace]
		tCount.cnt.format
	}

	def dispatch void format(FunctionCall fc, extension IFormattableDocument document) {
		fc.expr.format
	}

	def dispatch void format(Plus plus, extension IFormattableDocument document) {
		plus.left.format
		plus.regionFor.keyword(additionAccess.plusSignKeyword_1_0_0_1).surround[oneSpace]
		plus.right.format
	}

	def dispatch void format(Minus minus, extension IFormattableDocument document) {
		minus.left.format
		minus.regionFor.keyword(additionAccess.hyphenMinusKeyword_1_0_1_1).surround[oneSpace]
		minus.right.format
	}

	def dispatch void format(Multi mul, extension IFormattableDocument document) {
		mul.left.format
		mul.regionFor.keyword(multiplicationAccess.asteriskKeyword_1_0_0_1).surround[oneSpace]
		mul.right.format
	}

	def dispatch void format(Div div, extension IFormattableDocument document) {
		div.left.format
		div.regionFor.keyword(multiplicationAccess.solidusKeyword_1_0_1_1).surround[oneSpace]
		div.right.format
	}

	def dispatch void format(Pow pow, extension IFormattableDocument document) {
		pow.left.format
		pow.regionFor.keyword(multiplicationAccess.circumflexAccentKeyword_1_0_2_1).surround[oneSpace]
		pow.right.format
	}
	
	def private maxRuleHeadLength(Complex complex){
		var maxLength = 0
		for(ComplexElement cElem : complex.elements){
			if(cElem instanceof Rule){
				val rHead = (cElem as Rule).head
				val rHeadLength = rHead.regionForEObject.length
				if(rHeadLength > maxLength){
					maxLength = rHeadLength
				}
			}
		}
		return maxLength
	}
}
