/*
 * generated by Xtext 2.19.0
 */
package org.reaction.dsl.validation

import com.google.common.collect.Lists
import com.google.inject.Inject
import java.util.ArrayList
import java.util.List
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.util.SimpleAttributeResolver
import org.eclipse.xtext.validation.Check
import org.reaction.dsl.reactionLanguage.Agent
import org.reaction.dsl.reactionLanguage.AgentInstance
import org.reaction.dsl.reactionLanguage.BlankPattern
import org.reaction.dsl.reactionLanguage.Bond
import org.reaction.dsl.reactionLanguage.BondSide
import org.reaction.dsl.reactionLanguage.BondSideOrWildcard
import org.reaction.dsl.reactionLanguage.BondType
import org.reaction.dsl.reactionLanguage.Bonds
import org.reaction.dsl.reactionLanguage.Complex
import org.reaction.dsl.reactionLanguage.Div
import org.reaction.dsl.reactionLanguage.FunctionCall
import org.reaction.dsl.reactionLanguage.InitialisationBody
import org.reaction.dsl.reactionLanguage.InitialisationHead
import org.reaction.dsl.reactionLanguage.MathFunc
import org.reaction.dsl.reactionLanguage.Observable
import org.reaction.dsl.reactionLanguage.ObservablePattern
import org.reaction.dsl.reactionLanguage.Pattern
import org.reaction.dsl.reactionLanguage.Rates
import org.reaction.dsl.reactionLanguage.ReactionLanguagePackage
import org.reaction.dsl.reactionLanguage.ReactionModel
import org.reaction.dsl.reactionLanguage.Rule
import org.reaction.dsl.reactionLanguage.RuleBody
import org.reaction.dsl.reactionLanguage.RuleHead
import org.reaction.dsl.reactionLanguage.RuleType
import org.reaction.dsl.reactionLanguage.Signature
import org.reaction.dsl.reactionLanguage.SiteInstance
import org.reaction.dsl.reactionLanguage.TerminateBody
import org.reaction.dsl.reactionLanguage.TerminateCount
import org.reaction.dsl.reactionLanguage.TerminateIterations
import org.reaction.dsl.reactionLanguage.VarRef
import org.reaction.dsl.reactionLanguage.Variable
import org.reaction.dsl.interpreter.Calculator

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class ReactionLanguageValidator extends AbstractReactionLanguageValidator {

	@Inject Calculator calculator

	@Check
	def checkMultipleSiteCalls(Bonds bonds) {
		val siList = EcoreUtil2.getAllContentsOfType(bonds, SiteInstance)
		for (var i = 0; i < siList.size - 1; i++) {
			val si = siList.get(i)
			for (var j = i + 1; j < siList.size; j++) {
				val si2 = siList.get(j)

				val bondSide = si.eContainer as BondSide
				val bondSide2 = si2.eContainer as BondSide

				val aiAbstr = bondSide.abstractAgent
				val aiAbstr2 = bondSide2.abstractAgent
				if (aiAbstr instanceof AgentInstance && aiAbstr2 instanceof AgentInstance) {
					val ai = aiAbstr as AgentInstance
					val ai2 = aiAbstr2 as AgentInstance

					if (si.site.name.equals(si2.site.name) && ai.name.equals(ai2.name)) {
						error("Multiple site calls within a single pattern are not allowed",
							ReactionLanguagePackage.Literals.BONDS__BONDS)
					}
				}
			}
		}
	}

	@Check
	def checkIllegalInitialisationStates(InitialisationBody initBody) {
		val pattern = initBody.pattern as Pattern;
		if (pattern instanceof BlankPattern) {
			error("Cannot initialize empty pattern", ReactionLanguagePackage.Literals.INITIALISATION_BODY__PATTERN)
		} else {
			val initBonds = EcoreUtil2.getAllContentsOfType(pattern, Bond)
			for (initBond : initBonds) {
				val rhs = initBond.right
				val bondType = initBond.bondType
				if (rhs instanceof BondSideOrWildcard) {
					if ((rhs as BondSideOrWildcard).wildcard !== null && bondType == BondType.BOUND) {
						error("Cannot use underspecified agents in initializations.", initBond,
							ReactionLanguagePackage.Literals.BOND__BOND_TYPE)
					}
				}
			}
		}
	}

	@Check
	def genericAgentOnLeftSide(Bond bond) {
		val abstractAgent = bond.left.abstractAgent;
		if (abstractAgent instanceof Agent) {
			error("Cannot use generic Agents on left site of bond.", bond.left,
				ReactionLanguagePackage.Literals.ABSTRACT_AGENT__NAME);
		}
	}

	@Check
	def combinationWildcardAndBondtype(Bond bond) {
		val rbs = bond.right;
		val bondType = bond.bondType;
		if (rbs !== null && rbs.wildcard !== null) {
			if (bondType == BondType.BOUND && rbs.wildcard.nothing) {
				error("Wrong use of wildcard. Try \"+?\" or \"//0\".", ReactionLanguagePackage.Literals.BOND__RIGHT);
			}
			if (bondType == BondType.UNBOUND && rbs.wildcard.anything) {
				error("Wrong use of wildcard. Try \"+?\" or \"//0\".", ReactionLanguagePackage.Literals.BOND__RIGHT);
			}
		}
	}

	@Check
	def checkNoEmptyObservable(ObservablePattern obs) {
		if (obs.pattern instanceof BlankPattern) {
			error("Cannot observe empty pattern", ReactionLanguagePackage.Literals.OBSERVABLE_PATTERN__PATTERN)
		}
	}

	@Check
	def checkNoEmptyTerminate(TerminateCount tc) {
		if (tc.pattern instanceof BlankPattern) {
			error("Cannot match for empty pattern", ReactionLanguagePackage.Literals.TERMINATE_COUNT__PATTERN)
		}
	}

	@Check
	def checkNoLoopsInVariable(Variable aVar) {
		val referencedVars = EcoreUtil2.getAllContentsOfType(aVar, VarRef);
		for (referencedVar : referencedVars) {
			if (referencedVar.ref.name == aVar.name) {
				error("Cannot self-reference in own expression", getNameFeature(referencedVar));
			} else {
				var list = Lists.newArrayList;
				list.add(aVar);
				if (referencedVar.ref instanceof Variable) {
					checkNoArithmeticLoops(referencedVar.ref as Variable, list);
				}
			}
		}
	}

	@Check
	def checkNoMissingSiteInstanceOnLeftBondSide(Bond bond) {
		val leftSide = bond.left
		val siteInstance = leftSide.siteInstance;
		if (siteInstance === null && bond.bondType == BondType.BOUND) {
			error("No connections on agents allowed but only on sites", bond,
				ReactionLanguagePackage.Literals.BOND__LEFT);
		}
	}

// TODO Does method below work?
	@Check
	def checkNoDeadRule(Rule rule) {
		if (rule.body.rhs.equals(rule.body.lhs)) {
			warning("Rule is dead.", rule, ReactionLanguagePackage.Literals.RULE__BODY);
		}
	}

	@Check
	def checkRuleConcreteness(Rule rule) {
		val lhs = rule.body.lhs;
		val rhs = rule.body.rhs;

		if (!isConcrete(lhs, rhs)) {
			error("Rule is underspecified", rule, ReactionLanguagePackage.Literals.RULE__BODY);
		}

		if (rule.body.ruleType == RuleType.BI) {
			if (!isConcrete(rhs, lhs)) {
				error("Backwards rule is underspecified", rule, ReactionLanguagePackage.Literals.RULE__BODY);
			}
		}
	}

	def private boolean isConcrete(Pattern lhs, Pattern rhs) {

		if (rhs instanceof BlankPattern) {

			// check if a binding wildcard was used on the left side
			if (lhs instanceof BlankPattern) {
				return true;
			}

			val leftBonds = (lhs as Bonds).bonds;
			for (Bond bond : leftBonds) {
				val rightBondSide = bond.right;
				if (rightBondSide !== null && !(rightBondSide instanceof BondSide)) {
					if (rightBondSide.wildcard.anything) {
						return false;
					}
				}

			}
			return true;
		}

		// Forbid any unspecifications on the right side with exceptions
		val agentsLeftSide = getAgentsSpecifiedInPattern(lhs);
		val bonds = (rhs as Bonds).bonds;
		for (Bond bond : bonds) {
			val agentInstance = bond.left.abstractAgent as AgentInstance;
			val siteInstance = bond.left.siteInstance;

			if (siteInstance !== null && unOrUnderspecifiedInPattern(agentInstance, siteInstance, lhs)) {
				if (!bindingIsTheSameRightAsLeftWithoutState(agentInstance, siteInstance, lhs, rhs)) {
					return false;
				}
			}

			// only left side given
			// exception: only left side given on left side as well
			if (bond.right === null) {
				if (agentsLeftSide.contains(agentInstance)) {
					if (!unOrUnderspecifiedInPattern(agentInstance, lhs)) {
						return false;
					}
				}
			} else {

				// bound to generic
				val rightBondSideOrWild = bond.right;
				if (rightBondSideOrWild instanceof BondSide) {
					val abstractAgentRightSide = (rightBondSideOrWild as BondSide).abstractAgent;
					if (abstractAgentRightSide instanceof Agent &&
						!bindingIsTheSameRightAsLeft(agentInstance, siteInstance, lhs, rhs)) {
						return false;
					}
				} else {

					// bound to wildcard
					val wildcard = rightBondSideOrWild.wildcard;
					if (wildcard !== null) {

						// 1st exception: "free"-wildcard when agent was not defined on left side is allowed
						// 2nd exception: "free"-wildcard when agent was normally bound on left side is allowed
						if (wildcard.nothing) {

							// 1st exception
							if (agentsLeftSide.contains(agentInstance)) {
								// 2nd exception
								if (siteInstance === null) {
									val freeAgentsLeftSide = getFreeAgentsInPattern(lhs);
									if (!freeAgentsLeftSide.contains(agentInstance)) {
										return false;
									}
								} else if (!agentAndSiteWereConcreteOnLeftSide(agentInstance, siteInstance, lhs)) {
									return false;
								}
							}
						}
					}

					// exception: "underspecified"-wildcard when agent was defined the same way on left side is allowed
					if (wildcard.anything) {
						if (siteInstance === null) {
							return false;
						} else {
							if (!bindingIsTheSameRightAsLeft(agentInstance, siteInstance, lhs, rhs)) {
								return false;
							}
						}
					}
				}
			}
		}

		return true;
	}

	def private AgentInstance getAgentInstanceFromPattern(Pattern pattern, String name) {
		for (AgentInstance ini : getAgentsSpecifiedInPattern(pattern)) {
			if (ini.name.equals(name)) {
				return ini
			}
		}
		return null
	}

	def private List<AgentInstance> getFreeAgentsInPattern(Pattern pattern) {
		if (pattern instanceof BlankPattern) {
			return new ArrayList();
		} else {
			var freeAgentsLeftSide = new ArrayList();
			for (Bond bond : (pattern as Bonds).bonds) {
				if (bond.right !== null) {
					val rightSide = bond.right;
					val leftSide = bond.left;

					if (rightSide.wildcard !== null) {
						val abstractAgentLeft = (leftSide as BondSide).abstractAgent;
						if (abstractAgentLeft instanceof AgentInstance && rightSide.wildcard.nothing) {
							freeAgentsLeftSide.add(abstractAgentLeft as AgentInstance);
						}
					}
				}
			}

			return freeAgentsLeftSide;
		}
	}

	def private unOrUnderspecifiedInPattern(AgentInstance ai, Pattern lhs) {
		if (lhs instanceof BlankPattern) {
			return false;
		}

		for (Bond bond : (lhs as Bonds).bonds) {
			val agentInstanceBond = bond.left.abstractAgent as AgentInstance;
			if (agentInstanceBond.name == ai.name) {
				if (bond.right === null) {
					return true;
				}
			}
		}
		return false;
	}

	def private unOrUnderspecifiedInPattern(AgentInstance ai, SiteInstance si, Pattern lhs) {
		if (lhs instanceof BlankPattern) {
			return false;
		}

		for (Bond bond : (lhs as Bonds).bonds) {
			val agentInstanceBond = bond.left.abstractAgent as AgentInstance;
			val siteInstanceBond = bond.left.siteInstance;
			if (siteInstanceBond !== null && agentInstanceBond.name == ai.name) {
				if (siteInstanceBond.site.name == si.site.name) {
					val bondRightSideOrWildcard = bond.right;
					if (bondRightSideOrWildcard === null) {
						return true;
					} else {
						if (bondRightSideOrWildcard.wildcard !== null && bondRightSideOrWildcard.wildcard.anything) {
							return true;
						}
					}
				}
			}
		}
		return false;
	}

	def private agentAndSiteWereConcreteOnLeftSide(AgentInstance ai, SiteInstance si, Pattern pattern) {
		if (pattern instanceof BlankPattern) {
			return true;
		}

		for (Bond bond : (pattern as Bonds).bonds) {
			val leftBondSide = bond.left;
			val rightBondSideOrWild = bond.right;

			// check left agent
			val leftAgent = leftBondSide.abstractAgent as AgentInstance;
			val leftSiteInstance = leftBondSide.siteInstance;
			if (leftSiteInstance !== null && leftAgent.name == ai.name && leftSiteInstance.site.name == si.site.name) {

				// check binding state
				val wildcard = rightBondSideOrWild.wildcard;
				if (wildcard !== null) {
					if (wildcard.anything) {
						return false;
					}
				} else {
					val rightBondSide = rightBondSideOrWild as BondSide;
					if (rightBondSide.abstractAgent instanceof AgentInstance) {
						val rightAgentInstance = rightBondSide.abstractAgent as AgentInstance;
						val rightSiteInstance = rightBondSide.siteInstance;
						if (rightSiteInstance !== null) {
							if (rightAgentInstance.name == ai.name && rightSiteInstance.site.name == si.site.name) {
								return true;
							}
						}
					}
				}
				return true;

			} else {
				if (rightBondSideOrWild !== null && rightBondSideOrWild.wildcard === null) {
					val rightBondSide = rightBondSideOrWild as BondSide;
					if (rightBondSide.abstractAgent instanceof Agent) {
						return false;
					} else {
						val rightAgentInstance = rightBondSide.abstractAgent as AgentInstance;
						val rightSiteInstance = rightBondSide.siteInstance;
						if (rightSiteInstance !== null) {
							if (rightAgentInstance.name == ai.name && rightSiteInstance.site.name == si.site.name) {
								return true;
							}
						}
					}
				}
			}
		}

		return false;
	}

	def private bindingIsTheSameRightAsLeftWithoutState(AgentInstance ai, SiteInstance si, Pattern left,
		Pattern right) {

		if (ai === null || si === null || left instanceof BlankPattern || right instanceof BlankPattern) {
			return false;
		}

		val bondsLeft = (left as Bonds).bonds;
		val bondsRight = (right as Bonds).bonds;

		for (Bond bond : bondsLeft) {
			val leftBondSide = bond.left;
			val leftAi = leftBondSide.abstractAgent as AgentInstance;
			if (leftAi.name.equals(ai.name)) {
				val leftSi = leftBondSide.siteInstance;
				if (leftSi !== null) {
					if (leftSi.site.name.equals(si.site.name)) {
						val bondTypeLeft = bond.bondType;
						val boundToLeft = bond.right;

						for (Bond bondRight : bondsRight) {

							val rightPatternLeftBondSide = bondRight.left;
							val rightPatternLeftBondAgentInstance = rightPatternLeftBondSide.
								abstractAgent as AgentInstance;
							if (rightPatternLeftBondAgentInstance.name.equals(ai.name)) {
								val rightPatternLeftSiteInstance = rightPatternLeftBondSide.siteInstance;
								if (rightPatternLeftSiteInstance !== null &&
									rightPatternLeftSiteInstance.site.name.equals(si.site.name)) {
									val bondTypeRight = bondRight.bondType;
									val boundToRight = bondRight.right;
									if (bondTypeLeft == bondTypeRight) {
										if (boundToLeft === null && boundToRight === null) {
											return true;
										} else if (boundToLeft instanceof BondSide &&
											boundToRight instanceof BondSide) {

											val boundToLeftAbstractAgent = (boundToLeft as BondSide).abstractAgent;
											val boundToRightAbstractAgent = (boundToRight as BondSide).abstractAgent;

											if (boundToLeftAbstractAgent instanceof Agent &&
												boundToRightAbstractAgent instanceof Agent) {
												val boundToLeftAgent = boundToLeftAbstractAgent as Agent;
												val boundToRightAgent = boundToRightAbstractAgent as Agent;

												if (boundToLeftAgent.name == boundToRightAgent.name) {

													// check site instance
													val boundToLeftSiteInstance = (boundToLeft as BondSide).
														siteInstance;
													val boundToRightSiteInstance = (boundToRight as BondSide).
														siteInstance;

													if (boundToLeftSiteInstance !== null &&
														boundToRightSiteInstance !== null) {

														if (boundToLeftSiteInstance.site.name ==
															boundToRightSiteInstance.site.name) {

															return true;
														}
													} else if (boundToLeftSiteInstance === null &&
														boundToRightSiteInstance === null) {
														return true;
													} else {
														return false;
													}
												}
											}
										}

										if (boundToLeft instanceof BondSideOrWildcard &&
											boundToRight instanceof BondSideOrWildcard) {
											val wildcardLeft = (boundToLeft as BondSideOrWildcard).wildcard;
											val wildcardRight = (boundToRight as BondSideOrWildcard).wildcard;

											if (wildcardLeft !== null && wildcardRight !== null) {
												if ((wildcardLeft.nothing && wildcardRight.nothing) ||
													(wildcardLeft.anything && wildcardRight.anything)) {
													return true;
												}
											}

										}

									}
								}
								return false;
							}
						}
					}
				}
			}
		}
		return false;
	}

	def private bindingIsTheSameRightAsLeft(AgentInstance ai, SiteInstance si, Pattern left, Pattern right) {
		if (ai === null || si === null || left instanceof BlankPattern || right instanceof BlankPattern) {
			return false;
		}

		val bondsLeft = (left as Bonds).bonds;
		val bondsRight = (right as Bonds).bonds;

		for (Bond bond : bondsLeft) {
			val leftBondSide = bond.left;
			val leftAi = leftBondSide.abstractAgent as AgentInstance;
			if (leftAi.name.equals(ai.name)) {
				val leftSi = leftBondSide.siteInstance;
				if (leftSi !== null) {
					if (leftSi.site.name.equals(si.site.name)) {
						val bondTypeLeft = bond.bondType;
						val boundToLeft = bond.right;

						for (Bond bondRight : bondsRight) {

							val rightPatternLeftBondSide = bondRight.left;
							val rightPatternLeftBondAgentInstance = rightPatternLeftBondSide.
								abstractAgent as AgentInstance;
							if (rightPatternLeftBondAgentInstance.name.equals(ai.name)) {
								val rightPatternLeftSiteInstance = rightPatternLeftBondSide.siteInstance;
								if (rightPatternLeftSiteInstance !== null &&
									rightPatternLeftSiteInstance.site.name.equals(si.site.name)) {
									val bondTypeRight = bondRight.bondType;
									val boundToRight = bondRight.right;
									if (bondTypeLeft == bondTypeRight) {
										if (boundToLeft instanceof BondSide && boundToRight instanceof BondSide) {

											val boundToLeftAbstractAgent = (boundToLeft as BondSide).abstractAgent;
											val boundToRightAbstractAgent = (boundToRight as BondSide).abstractAgent;

											if (boundToLeftAbstractAgent instanceof Agent &&
												boundToRightAbstractAgent instanceof Agent) {
												val boundToLeftAgent = boundToLeftAbstractAgent as Agent;
												val boundToRightAgent = boundToRightAbstractAgent as Agent;

												if (boundToLeftAgent.name == boundToRightAgent.name) {

													// check site instance
													val boundToLeftSiteInstance = (boundToLeft as BondSide).
														siteInstance;
													val boundToRightSiteInstance = (boundToRight as BondSide).
														siteInstance;

													if (boundToLeftSiteInstance !== null &&
														boundToRightSiteInstance !== null) {

														if (boundToLeftSiteInstance.site.name ==
															boundToRightSiteInstance.site.name) {

															val boundToLeftState = boundToLeftSiteInstance.siteState;
															val boundToRightState = boundToRightSiteInstance.siteState;
															if (boundToLeftState !== null &&
																boundToRightState !== null) {
																if (boundToLeftState.state.name ==
																	boundToRightState.state.name) {
																	return true;
																}
															} else if (boundToLeftState === null &&
																boundToRightState === null) {
																return true;
															} else {
																return false;
															}
														}
													} else if (boundToLeftSiteInstance === null &&
														boundToRightSiteInstance === null) {
														return true;
													} else {
														return false;
													}
												}
											}
										}

										if (boundToLeft instanceof BondSideOrWildcard &&
											boundToRight instanceof BondSideOrWildcard) {
											val wildcardLeft = (boundToLeft as BondSideOrWildcard).wildcard;
											val wildcardRight = (boundToRight as BondSideOrWildcard).wildcard;

											if (wildcardLeft !== null && wildcardRight !== null) {
												if ((wildcardLeft.nothing && wildcardRight.nothing) ||
													(wildcardLeft.anything && wildcardRight.anything)) {
													return true;
												}
											}

										}

									}
								}
								return false;
							}
						}
					}
				}
			}
		}
		return false;
	}

	def private siteWasBoundToGeneric(SiteInstance si, Pattern lhs) {
		if (lhs instanceof BlankPattern) {
			return false;
		} else {
			val bonds = (lhs as Bonds).bonds;
			for (Bond bond : bonds) {
				val leftSiteInstance = bond.left.siteInstance;
				if (leftSiteInstance !== null) {
					val rightBondSideOrWild = bond.right;
					if (rightBondSideOrWild instanceof BondSide) {
						val rightBondSide = rightBondSideOrWild as BondSide
						val abstractAgent = rightBondSide.abstractAgent;
						if (leftSiteInstance.site == si.site && abstractAgent instanceof Agent) {
							return true;
						}
					}
				}
			}
			return false;
		}
	}

	def private List<AgentInstance> getAgentsSpecifiedInPattern(Pattern pattern) {
		if (pattern instanceof BlankPattern) {
			return new ArrayList();
		} else {
			var specifiedAgentsSide = new ArrayList();
			for (Bond bond : (pattern as Bonds).bonds) {
				val abstractAgent = bond.left.abstractAgent;
				if (abstractAgent instanceof AgentInstance) {
					val agentInstance = abstractAgent as AgentInstance;
					if (!specifiedAgentsSide.contains(agentInstance)) {
						specifiedAgentsSide.add(agentInstance);
					}

				}
				if (bond.right !== null) {
					val rightSide = bond.right;

					if (rightSide.wildcard === null) {
						val abstractAgentRight = (rightSide as BondSide).abstractAgent;
						if (abstractAgentRight instanceof AgentInstance) {
							val agentInstanceRight = abstractAgentRight as AgentInstance;
							if (!specifiedAgentsSide.contains(agentInstanceRight)) {
								specifiedAgentsSide.add(agentInstanceRight);
							}
						}
					}
				}
			}
			return specifiedAgentsSide;
		}
	}

	@Check
	def checkNoGenericsOnLeftBondSide(Bonds bonds) {
		for (Bond bond : bonds.bonds) {
			if (bond.left.abstractAgent instanceof Agent) {
				error("No generic Agents on left side of bond allowed", bond.left,
					ReactionLanguagePackage.Literals.BOND_SIDE__ABSTRACT_AGENT);
			}
		}
	}

	@Check
	def checkNoUnderspecifiedStateChanges(Rule rule) {
		val patternLeft = rule.body.lhs;
		val patternRight = rule.body.rhs;

		var specifiedAgentsLeftSide = getAgentsSpecifiedInPattern(patternLeft);

		if (!(patternLeft instanceof BlankPattern || patternRight instanceof BlankPattern)) {
			val bondsLeft = patternLeft as Bonds;
			val bondsRight = patternRight as Bonds;

			var sitesInStateLeft = new ArrayList();

			for (Bond bond : bondsLeft.bonds) {
				val siteInstance = bond.left.siteInstance;
				if (siteInstance !== null && siteInstance.siteState !== null) {
					sitesInStateLeft.add(siteInstance);
				}
			}

			for (Bond bond : bondsRight.bonds) {

				val abstractAgentLeft = bond.left.abstractAgent;

				if (abstractAgentLeft instanceof AgentInstance) {
					var agentInstanceLeft = abstractAgentLeft as AgentInstance;

					if (!specifiedAgentsLeftSide.contains(agentInstanceLeft)) {
						/* Nothing */
					} else {
						val siteInstanceLeft = bond.left.siteInstance;
						if (siteInstanceLeft !== null) {
							val siteState = siteInstanceLeft.siteState;
							if (siteState !== null &&
								!isSiteStateSpecifiedInPattern(agentInstanceLeft, siteInstanceLeft, patternLeft)) {
								error("Underspecified state change", siteInstanceLeft,
									ReactionLanguagePackage.Literals.SITE_INSTANCE__SITE_STATE);
							}
						}

						val bondRight = bond.right;
						if (bondRight !== null && bondRight.wildcard === null) {
							val bondSideRight = bond.right as BondSide;
							val abstractAgentRight = bondSideRight.abstractAgent;
							if (abstractAgentRight instanceof AgentInstance) {
								val agentInstanceRight = abstractAgentRight as AgentInstance;
								if (!specifiedAgentsLeftSide.contains(agentInstanceRight)) {
									/* Nothing */
								} else {
									val siteInstanceRight = bondSideRight.siteInstance;
									if (siteInstanceRight !== null) {
										val siteState = siteInstanceRight.siteState;
										if (siteState !== null &&
											!isSiteStateSpecifiedInPattern(agentInstanceRight, siteInstanceRight,
												patternLeft)) {
											error("Underspecified state change", siteInstanceRight,
												ReactionLanguagePackage.Literals.SITE_INSTANCE__SITE_STATE);
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	def private boolean isSiteSpecifiedInPattern(AgentInstance ai, SiteInstance si, Pattern pattern) {
		if (pattern instanceof BlankPattern) {
			return false;
		} else {

			val bonds = pattern as Bonds;
			for (Bond bond : bonds.bonds) {

				val leftAbstract = bond.left.abstractAgent;
				if (leftAbstract instanceof AgentInstance) {
					val leftAi = leftAbstract as AgentInstance;
					val leftSi = bond.left.siteInstance;
					if (leftSi !== null) {

						if (leftAi.name == ai.name && leftSi.site.name == si.site.name) {
							return true;
						}
					}
				}

				if (bond.right instanceof BondSide) {
					val rightBondSide = bond.right as BondSide;
					val rightAbstract = rightBondSide.abstractAgent;
					if (rightAbstract instanceof AgentInstance) {
						val rightAi = rightAbstract as AgentInstance;
						val rightSi = rightBondSide.siteInstance;
						if (rightSi !== null) {

							if (rightAi.name == ai.name && rightSi.site.name == si.site.name) {
								return true;
							}
						}
					}
				}
			}

		}

		return false;
	}

	def private boolean isSiteStateSpecifiedInPattern(AgentInstance ai, SiteInstance si, Pattern pattern) {
		if (pattern instanceof BlankPattern) {
			return false;
		} else {

			val bonds = pattern as Bonds;
			for (Bond bond : bonds.bonds) {

				val leftAbstract = bond.left.abstractAgent;
				if (leftAbstract instanceof AgentInstance) {
					val leftAi = leftAbstract as AgentInstance;
					val leftSi = bond.left.siteInstance;
					if (leftSi !== null) {
						val leftState = leftSi.siteState;

						if (leftState !== null && leftAi.name == ai.name && leftSi.site.name == si.site.name) {
							return true;
						}
					}
				}

				if (bond.right instanceof BondSide) {
					val rightBondSide = bond.right as BondSide;
					val rightAbstract = rightBondSide.abstractAgent;
					if (rightAbstract instanceof AgentInstance) {
						val rightAi = rightAbstract as AgentInstance;
						val rightSi = rightBondSide.siteInstance;
						if (rightSi !== null) {
							val rightState = rightSi.siteState;

							if (rightState !== null && rightAi.name == ai.name && rightSi.site.name == si.site.name) {
								return true;
							}
						}
					}
				}
			}

		}

		return false;
	}

	@Check
	def checkSiteIsNotNull(Bond bond) {
		val leftSide = bond.left;
		val rightSide = bond.right;
		val bondType = bond.bondType;

		if (rightSide === null) {
			return;
		}

		if (bondType == BondType.UNBOUND && rightSide.wildcard !== null) {
			return;
		}

		if (leftSide.siteInstance === null) {
			error("Site is missing", bond, ReactionLanguagePackage.Literals.BOND__LEFT);
		}
	}

	@Check
	def checkNoMultipleUnderspecifiedBindingsOnLeftSide(Rule rule) {
		val leftSide = rule.body.lhs;
		if (!(leftSide instanceof BlankPattern)) {
			val leftBonds = leftSide as Bonds;

			var oneUnderspecifiedBinding = false;
			for (Bond bond : leftBonds.bonds) {
				if (bond.right !== null) {
					val wildcard = bond.right.wildcard;

					val siteInstance = bond.left.siteInstance;
					if (siteInstance === null && wildcard !== null && wildcard.anything) {
						error("Only one underspecified binding on left side allowed", bond,
							ReactionLanguagePackage.Literals.BOND__LEFT);
					}

					if (wildcard !== null && wildcard.anything) {
						if (oneUnderspecifiedBinding) {
							error("Only one underspecified binding on left side allowed", bond,
								ReactionLanguagePackage.Literals.BOND__RIGHT);
						} else {
							oneUnderspecifiedBinding = true;
						}
					}
				}
			}
		}
	}

	def private void checkNoArithmeticLoops(Variable aVar, List<Variable> collectedVars) {
		if (collectedVars.contains(aVar)) {
			error("Reference loop!", ReactionLanguagePackage.Literals.VARIABLE__VALUE)
		} else {
			val referencedVars = EcoreUtil2.getAllContentsOfType(aVar, VarRef);
			collectedVars.add(aVar);
			for (referencedVar : referencedVars) {
				if (referencedVar.ref instanceof Variable) {
					checkNoArithmeticLoops(referencedVar.ref as Variable, collectedVars);
				}
			}
		}
	}

	@Check
	def checkForUnusedAgentInstances(Signature signature) {
		if (!(signature.eContainer instanceof ObservablePattern)) { // TODO: Expand to observables where usage-cross-referencer not seems to work yet
			val agentInstances = signature.instances;
			var contentToSearch = null as EObject;

			if (signature.eContainer instanceof RuleHead) {
				val head = signature.eContainer;
				contentToSearch = (head.eContainer as Rule).body as RuleBody;
			}

			if (signature.eContainer instanceof Complex) {
				contentToSearch = signature.eContainer as Complex;
			}

			if (signature.eContainer instanceof InitialisationBody) {
				contentToSearch = signature.eContainer as InitialisationBody;
			}

			if (signature.eContainer instanceof Observable) {
				contentToSearch = signature.eContainer as Observable;
			}

			if (signature.eContainer instanceof TerminateCount) {
				contentToSearch = signature.eContainer as TerminateCount;
			}

			for (agentInstance : agentInstances) {

				if (EcoreUtil.UsageCrossReferencer.find(agentInstance, contentToSearch).empty) {
					warning("Agent instance " + agentInstance.name + " is not used", agentInstance,
						getNameFeature(agentInstance));
				}
			}

		}
	}

	@Check
	def checkRuleSignatureExists(Rule rule) {
		val signature = rule.head.signature;
		if (signature === null && !isObjectInComplex(rule)) {
			error("Signature needed when using patterns", ReactionLanguagePackage.Literals.RULE__BODY);
		}

	}

	def private isObjectInComplex(EObject obj) {
		var containerTraverser = obj;
		while (!(containerTraverser instanceof Complex)) {
			if (containerTraverser instanceof ReactionModel) {
				return false;
			}
			containerTraverser = containerTraverser.eContainer;
		}
		return true;
	}

	@Check
	def checkTerminateSignatureExists(TerminateCount tCount) {
		val signature = tCount.signature;
		if (signature === null) {
			error("Signature needed when using patterns.", ReactionLanguagePackage.Literals.TERMINATE_COUNT__PATTERN);
		}
	}

	@Check
	def checkNestedUniqueAgentInstanceNames(AgentInstance aInstance) {
		if (aInstance.eContainer instanceof Signature) {

			var aInstancesInSignatures = Lists.newArrayList();
			var containerTraverser = aInstance.eContainer;

			while (!(containerTraverser instanceof ReactionModel)) {

				if (containerTraverser instanceof Signature) {
					aInstancesInSignatures.addAll((containerTraverser as Signature).instances);
				}

				if (containerTraverser instanceof Complex) {
					aInstancesInSignatures.addAll((containerTraverser as Complex).signature.instances);
				}

				containerTraverser = containerTraverser.eContainer;
			}

			for (otherAInstance : aInstancesInSignatures) {
				if (aInstance !== otherAInstance && aInstance.name == otherAInstance.name) {
					val nameFeature = getNameFeature(aInstance);
					error("Duplicate AgentInstance " + aInstance.name, aInstance, nameFeature);
					error("Duplicate AgentInstance " + aInstance.name, otherAInstance, nameFeature);
				}
			}
		}

	}

	def private EStructuralFeature getNameFeature(EObject object) {
		return SimpleAttributeResolver.NAME_RESOLVER.getAttribute(object);
	}

	@Check
	def checkSecondRateExits(Rates rates) {
		var containerTraverser = rates.eContainer;
		var rule = null as Rule;

		while (!(containerTraverser instanceof Rule)) {
			containerTraverser = containerTraverser.eContainer;
		}
		if (containerTraverser instanceof Rule) {
			rule = containerTraverser;
		}

		val ruleType = rule.body.ruleType
		if (ruleType == RuleType.BI && !rates.rateBackwardSet) {
			error("Rates for bidirectional rule are not complete. Maybe you forgot the rate for the backwards rule?",
				ReactionLanguagePackage.Literals.RATES__RATE_FORWARD);
		}
		if (ruleType == RuleType.UNI && rates.rateBackwardSet) {
			error("For unidirectional rules only one rate is allowed",
				ReactionLanguagePackage.Literals.RATES__RATE_BACKWARD);
		}
	}

	@Check
	def checkArrayInstancesRightBondSide(BondSide bondSide) {
		val abstractAgent = bondSide.abstractAgent;

		if (abstractAgent instanceof AgentInstance) {
			val aInstance = abstractAgent as AgentInstance;

//			checkArraySize(aInstance);
			if (bondSide.isArray && aInstance.isArray) {
				if (bondSide.index >= aInstance.size) {
					error("Index out of range", ReactionLanguagePackage.Literals.BOND_SIDE__INDEX);
				}
			}

			if (!bondSide.isArray && aInstance.isArray) {
				warning("Array access without index", ReactionLanguagePackage.Literals.BOND_SIDE__ABSTRACT_AGENT);
			}

			if (bondSide.isArray && !aInstance.isArray) {
				error("Cannot access simple agents as array",
					ReactionLanguagePackage.Literals.BOND_SIDE__ABSTRACT_AGENT);
			}
		}

		if (abstractAgent instanceof Agent) {
			if (bondSide.isArray) {
				error("Generic arrays are not allowed", ReactionLanguagePackage.Literals.BOND_SIDE__ARRAY);
			}
		}
	}

	@Check
	def checkComplexNotEmpty(Complex complex) {
		if (complex.eContents.isEmpty) {
			warning("Complex is empty", ReactionLanguagePackage.Literals.COMPLEX__ELEMENTS)
		}
	}

	def private <T extends EObject> getAllSignatureMembers(T context) {
		var signature = null as Signature;
		var containerTraverser = context.eContainer;
		var candidates = new ArrayList();

		while (!(containerTraverser instanceof ReactionModel)) {
			containerTraverser = containerTraverser.eContainer;

			if (containerTraverser instanceof Rule) {
				signature = containerTraverser.head.signature;
			}

			if (containerTraverser instanceof Complex) {
				signature = containerTraverser.signature;
			}

			if (containerTraverser instanceof InitialisationBody) {
				signature = containerTraverser.signature;
			}

			if (containerTraverser instanceof ObservablePattern) {
				signature = containerTraverser.signature;
			}

			if (containerTraverser instanceof TerminateCount) {
				signature = containerTraverser.signature;
			}

			if (signature !== null) {
				candidates.addAll(signature.instances);
			}

		}

		return candidates;
	}

	@Check
	def checkInitialisationCnt(InitialisationHead initHead) {
		val cnt = calculator.evaluate(initHead.cnt)

		if (cnt < 0) {
			error("Cannot initialize negative amount", ReactionLanguagePackage.Literals.INITIALISATION_HEAD__CNT)
		}
		if (cnt == 0) {
			warning("Initializing nothing", ReactionLanguagePackage.Literals.INITIALISATION_HEAD__CNT)
		}
		if (cnt != Math.floor(cnt)) {
			error("Can only initialise integer amounts", ReactionLanguagePackage.Literals.INITIALISATION_HEAD__CNT)
		}
	}

	@Check
	def checkTerminate(TerminateBody tBody) {
		if (tBody instanceof TerminateIterations) {
			val cnt = (tBody as TerminateIterations).iterations
			val eval = calculator.evaluate(cnt)
			if (eval != Math.floor(eval)) {
				error("Can only execute whole iterations",
					ReactionLanguagePackage.eINSTANCE.terminateIterations_Iterations)
			}
		}
		if (tBody instanceof TerminateCount) {
			val cnt = (tBody as TerminateCount).cnt
			val eval = calculator.evaluate(cnt)
			if (eval != Math.floor(eval)) {
				error("Can only match for integer amount", ReactionLanguagePackage.eINSTANCE.terminateCount_Cnt)
			}
		}
	}

//----------------------------------Checking Arithmetics--------------------------------------
	@Check
	def checkDivideByZero(Div div) {
		val divisor = calculator.evaluate(div.right)
		if (divisor == 0.0) {
			error("Division by zero!", ReactionLanguagePackage.eINSTANCE.div_Right)
		}
	}

	@Check
	def checkNegativeSqrt(FunctionCall fc) {
		if (fc.func == MathFunc.SQRT && calculator.evaluate(fc.expr) < 0) {
			error("Negative discriminant!", ReactionLanguagePackage.Literals.FUNCTION_CALL__EXPR)
		}
	}

	@Check
	def checkNoNegativeRates(Rates rates) {
		if (calculator.evaluate(rates.rateForward) < 0) {
			error("No negative rates allowed", ReactionLanguagePackage.Literals.RATES__RATE_FORWARD)
		}
		if (calculator.evaluate(rates.rateForward) == 0) {
			warning(
				"Reaction rate is zero",
				ReactionLanguagePackage.Literals.RATES__RATE_FORWARD
			)
		}

		if (rates.rateBackward !== null) {
			if (calculator.evaluate(rates.rateBackward) < 0) {
				error("No negative rates allowed", ReactionLanguagePackage.Literals.RATES__RATE_BACKWARD)
			}
			if (calculator.evaluate(rates.rateBackward) == 0) {
				warning("Reaction rate is zero", ReactionLanguagePackage.Literals.RATES__RATE_BACKWARD)
			}
		}
	}

}
