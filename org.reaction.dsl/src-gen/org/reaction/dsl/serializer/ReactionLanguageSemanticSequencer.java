/*
 * generated by Xtext 2.20.0
 */
package org.reaction.dsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.reaction.dsl.reactionLanguage.Agent;
import org.reaction.dsl.reactionLanguage.AgentDeclaration;
import org.reaction.dsl.reactionLanguage.AgentInstance;
import org.reaction.dsl.reactionLanguage.BlankPattern;
import org.reaction.dsl.reactionLanguage.Bond;
import org.reaction.dsl.reactionLanguage.BondSide;
import org.reaction.dsl.reactionLanguage.BondSideOrWildcard;
import org.reaction.dsl.reactionLanguage.Bonds;
import org.reaction.dsl.reactionLanguage.Complex;
import org.reaction.dsl.reactionLanguage.Div;
import org.reaction.dsl.reactionLanguage.FunctionCall;
import org.reaction.dsl.reactionLanguage.Initialisation;
import org.reaction.dsl.reactionLanguage.InitialisationBody;
import org.reaction.dsl.reactionLanguage.InitialisationHead;
import org.reaction.dsl.reactionLanguage.Minus;
import org.reaction.dsl.reactionLanguage.Multi;
import org.reaction.dsl.reactionLanguage.NumberLiteral;
import org.reaction.dsl.reactionLanguage.Observable;
import org.reaction.dsl.reactionLanguage.ObservableArithmetic;
import org.reaction.dsl.reactionLanguage.ObservablePattern;
import org.reaction.dsl.reactionLanguage.Plus;
import org.reaction.dsl.reactionLanguage.Pow;
import org.reaction.dsl.reactionLanguage.Rates;
import org.reaction.dsl.reactionLanguage.ReactionLanguagePackage;
import org.reaction.dsl.reactionLanguage.ReactionModel;
import org.reaction.dsl.reactionLanguage.Rule;
import org.reaction.dsl.reactionLanguage.RuleBody;
import org.reaction.dsl.reactionLanguage.RuleHead;
import org.reaction.dsl.reactionLanguage.Signature;
import org.reaction.dsl.reactionLanguage.Site;
import org.reaction.dsl.reactionLanguage.SiteInstance;
import org.reaction.dsl.reactionLanguage.SiteInstanceState;
import org.reaction.dsl.reactionLanguage.SiteState;
import org.reaction.dsl.reactionLanguage.TerminateCount;
import org.reaction.dsl.reactionLanguage.TerminateIterations;
import org.reaction.dsl.reactionLanguage.TerminateTime;
import org.reaction.dsl.reactionLanguage.VarRef;
import org.reaction.dsl.reactionLanguage.Variable;
import org.reaction.dsl.reactionLanguage.Wildcard;
import org.reaction.dsl.services.ReactionLanguageGrammarAccess;

@SuppressWarnings("all")
public class ReactionLanguageSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ReactionLanguageGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ReactionLanguagePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ReactionLanguagePackage.AGENT:
				sequence_Agent(context, (Agent) semanticObject); 
				return; 
			case ReactionLanguagePackage.AGENT_DECLARATION:
				sequence_AgentDeclaration(context, (AgentDeclaration) semanticObject); 
				return; 
			case ReactionLanguagePackage.AGENT_INSTANCE:
				sequence_AgentInstance(context, (AgentInstance) semanticObject); 
				return; 
			case ReactionLanguagePackage.BLANK_PATTERN:
				sequence_Pattern(context, (BlankPattern) semanticObject); 
				return; 
			case ReactionLanguagePackage.BOND:
				sequence_Bond(context, (Bond) semanticObject); 
				return; 
			case ReactionLanguagePackage.BOND_SIDE:
				sequence_BondSide(context, (BondSide) semanticObject); 
				return; 
			case ReactionLanguagePackage.BOND_SIDE_OR_WILDCARD:
				sequence_BondSideOrWildcard(context, (BondSideOrWildcard) semanticObject); 
				return; 
			case ReactionLanguagePackage.BONDS:
				sequence_Bonds(context, (Bonds) semanticObject); 
				return; 
			case ReactionLanguagePackage.COMPLEX:
				sequence_Complex(context, (Complex) semanticObject); 
				return; 
			case ReactionLanguagePackage.DIV:
				sequence_Multiplication(context, (Div) semanticObject); 
				return; 
			case ReactionLanguagePackage.FUNCTION_CALL:
				sequence_PrimaryExpr(context, (FunctionCall) semanticObject); 
				return; 
			case ReactionLanguagePackage.INITIALISATION:
				sequence_Initialisation(context, (Initialisation) semanticObject); 
				return; 
			case ReactionLanguagePackage.INITIALISATION_BODY:
				sequence_InitialisationBody(context, (InitialisationBody) semanticObject); 
				return; 
			case ReactionLanguagePackage.INITIALISATION_HEAD:
				sequence_InitialisationHead(context, (InitialisationHead) semanticObject); 
				return; 
			case ReactionLanguagePackage.MINUS:
				sequence_Addition(context, (Minus) semanticObject); 
				return; 
			case ReactionLanguagePackage.MULTI:
				sequence_Multiplication(context, (Multi) semanticObject); 
				return; 
			case ReactionLanguagePackage.NUMBER_LITERAL:
				sequence_PrimaryExpr(context, (NumberLiteral) semanticObject); 
				return; 
			case ReactionLanguagePackage.OBSERVABLE:
				sequence_Observable(context, (Observable) semanticObject); 
				return; 
			case ReactionLanguagePackage.OBSERVABLE_ARITHMETIC:
				sequence_ObservableArithmetic(context, (ObservableArithmetic) semanticObject); 
				return; 
			case ReactionLanguagePackage.OBSERVABLE_PATTERN:
				sequence_ObservablePattern(context, (ObservablePattern) semanticObject); 
				return; 
			case ReactionLanguagePackage.PLUS:
				sequence_Addition(context, (Plus) semanticObject); 
				return; 
			case ReactionLanguagePackage.POW:
				sequence_Multiplication(context, (Pow) semanticObject); 
				return; 
			case ReactionLanguagePackage.RATES:
				sequence_Rates(context, (Rates) semanticObject); 
				return; 
			case ReactionLanguagePackage.REACTION_MODEL:
				sequence_ReactionModel(context, (ReactionModel) semanticObject); 
				return; 
			case ReactionLanguagePackage.RULE:
				sequence_Rule(context, (Rule) semanticObject); 
				return; 
			case ReactionLanguagePackage.RULE_BODY:
				sequence_RuleBody(context, (RuleBody) semanticObject); 
				return; 
			case ReactionLanguagePackage.RULE_HEAD:
				sequence_RuleHead(context, (RuleHead) semanticObject); 
				return; 
			case ReactionLanguagePackage.SIGNATURE:
				sequence_Signature(context, (Signature) semanticObject); 
				return; 
			case ReactionLanguagePackage.SITE:
				sequence_Site(context, (Site) semanticObject); 
				return; 
			case ReactionLanguagePackage.SITE_INSTANCE:
				sequence_SiteInstance(context, (SiteInstance) semanticObject); 
				return; 
			case ReactionLanguagePackage.SITE_INSTANCE_STATE:
				sequence_SiteInstanceState(context, (SiteInstanceState) semanticObject); 
				return; 
			case ReactionLanguagePackage.SITE_STATE:
				sequence_SiteState(context, (SiteState) semanticObject); 
				return; 
			case ReactionLanguagePackage.TERMINATE_COUNT:
				sequence_TerminateCount(context, (TerminateCount) semanticObject); 
				return; 
			case ReactionLanguagePackage.TERMINATE_ITERATIONS:
				sequence_TerminateIterations(context, (TerminateIterations) semanticObject); 
				return; 
			case ReactionLanguagePackage.TERMINATE_TIME:
				sequence_TerminateTime(context, (TerminateTime) semanticObject); 
				return; 
			case ReactionLanguagePackage.VAR_REF:
				sequence_PrimaryExpr(context, (VarRef) semanticObject); 
				return; 
			case ReactionLanguagePackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case ReactionLanguagePackage.WILDCARD:
				sequence_Wildcard(context, (Wildcard) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ArithmeticExpr returns Minus
	 *     Addition returns Minus
	 *     Addition.Plus_1_0_0_0 returns Minus
	 *     Addition.Minus_1_0_1_0 returns Minus
	 *     Multiplication returns Minus
	 *     Multiplication.Multi_1_0_0_0 returns Minus
	 *     Multiplication.Div_1_0_1_0 returns Minus
	 *     Multiplication.Pow_1_0_2_0 returns Minus
	 *     PrimaryExpr returns Minus
	 *
	 * Constraint:
	 *     (left=Addition_Minus_1_0_1_0 right=Multiplication)
	 */
	protected void sequence_Addition(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReactionLanguagePackage.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReactionLanguagePackage.Literals.MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, ReactionLanguagePackage.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReactionLanguagePackage.Literals.MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionAccess().getMinusLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionAccess().getRightMultiplicationParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpr returns Plus
	 *     Addition returns Plus
	 *     Addition.Plus_1_0_0_0 returns Plus
	 *     Addition.Minus_1_0_1_0 returns Plus
	 *     Multiplication returns Plus
	 *     Multiplication.Multi_1_0_0_0 returns Plus
	 *     Multiplication.Div_1_0_1_0 returns Plus
	 *     Multiplication.Pow_1_0_2_0 returns Plus
	 *     PrimaryExpr returns Plus
	 *
	 * Constraint:
	 *     (left=Addition_Plus_1_0_0_0 right=Multiplication)
	 */
	protected void sequence_Addition(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReactionLanguagePackage.Literals.PLUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReactionLanguagePackage.Literals.PLUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, ReactionLanguagePackage.Literals.PLUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReactionLanguagePackage.Literals.PLUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionAccess().getPlusLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionAccess().getRightMultiplicationParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Component returns AgentDeclaration
	 *     AgentDeclaration returns AgentDeclaration
	 *
	 * Constraint:
	 *     (declaredAgents+=Agent declaredAgents+=Agent*)
	 */
	protected void sequence_AgentDeclaration(ISerializationContext context, AgentDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AgentInstance returns AgentInstance
	 *     AbstractAgent returns AgentInstance
	 *
	 * Constraint:
	 *     (name=ID instanceOf=[Agent|ID] (array?='[' size=INT)?)
	 */
	protected void sequence_AgentInstance(ISerializationContext context, AgentInstance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Agent returns Agent
	 *     AbstractAgent returns Agent
	 *
	 * Constraint:
	 *     (name=ID (sites+=Site sites+=Site*)?)
	 */
	protected void sequence_Agent(ISerializationContext context, Agent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BondSideOrWildcard returns BondSideOrWildcard
	 *
	 * Constraint:
	 *     wildcard=Wildcard
	 */
	protected void sequence_BondSideOrWildcard(ISerializationContext context, BondSideOrWildcard semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReactionLanguagePackage.Literals.BOND_SIDE_OR_WILDCARD__WILDCARD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReactionLanguagePackage.Literals.BOND_SIDE_OR_WILDCARD__WILDCARD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBondSideOrWildcardAccess().getWildcardWildcardParserRuleCall_1_0(), semanticObject.getWildcard());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BondSideOrWildcard returns BondSide
	 *     BondSide returns BondSide
	 *
	 * Constraint:
	 *     (abstractAgent=[AbstractAgent|ID] (array?='[' index=UnsignedInt)? siteInstance=SiteInstance?)
	 */
	protected void sequence_BondSide(ISerializationContext context, BondSide semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Bond returns Bond
	 *
	 * Constraint:
	 *     (left=BondSide (bondType=BondType right=BondSideOrWildcard)?)
	 */
	protected void sequence_Bond(ISerializationContext context, Bond semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Bonds
	 *     Bonds returns Bonds
	 *
	 * Constraint:
	 *     (bonds+=Bond bonds+=Bond*)
	 */
	protected void sequence_Bonds(ISerializationContext context, Bonds semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Component returns Complex
	 *     Complex returns Complex
	 *     ComplexElement returns Complex
	 *
	 * Constraint:
	 *     (signature=Signature elements+=ComplexElement*)
	 */
	protected void sequence_Complex(ISerializationContext context, Complex semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InitialisationBody returns InitialisationBody
	 *
	 * Constraint:
	 *     (signature=Signature? pattern=Pattern)
	 */
	protected void sequence_InitialisationBody(ISerializationContext context, InitialisationBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InitialisationHead returns InitialisationHead
	 *
	 * Constraint:
	 *     cnt=ArithmeticExpr
	 */
	protected void sequence_InitialisationHead(ISerializationContext context, InitialisationHead semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReactionLanguagePackage.Literals.INITIALISATION_HEAD__CNT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReactionLanguagePackage.Literals.INITIALISATION_HEAD__CNT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInitialisationHeadAccess().getCntArithmeticExprParserRuleCall_1_0(), semanticObject.getCnt());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Component returns Initialisation
	 *     Initialisation returns Initialisation
	 *
	 * Constraint:
	 *     (head=InitialisationHead body=InitialisationBody)
	 */
	protected void sequence_Initialisation(ISerializationContext context, Initialisation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReactionLanguagePackage.Literals.INITIALISATION__HEAD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReactionLanguagePackage.Literals.INITIALISATION__HEAD));
			if (transientValues.isValueTransient(semanticObject, ReactionLanguagePackage.Literals.INITIALISATION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReactionLanguagePackage.Literals.INITIALISATION__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInitialisationAccess().getHeadInitialisationHeadParserRuleCall_0_0(), semanticObject.getHead());
		feeder.accept(grammarAccess.getInitialisationAccess().getBodyInitialisationBodyParserRuleCall_1_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpr returns Div
	 *     Addition returns Div
	 *     Addition.Plus_1_0_0_0 returns Div
	 *     Addition.Minus_1_0_1_0 returns Div
	 *     Multiplication returns Div
	 *     Multiplication.Multi_1_0_0_0 returns Div
	 *     Multiplication.Div_1_0_1_0 returns Div
	 *     Multiplication.Pow_1_0_2_0 returns Div
	 *     PrimaryExpr returns Div
	 *
	 * Constraint:
	 *     (left=Multiplication_Div_1_0_1_0 right=PrimaryExpr)
	 */
	protected void sequence_Multiplication(ISerializationContext context, Div semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReactionLanguagePackage.Literals.DIV__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReactionLanguagePackage.Literals.DIV__LEFT));
			if (transientValues.isValueTransient(semanticObject, ReactionLanguagePackage.Literals.DIV__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReactionLanguagePackage.Literals.DIV__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationAccess().getDivLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationAccess().getRightPrimaryExprParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpr returns Multi
	 *     Addition returns Multi
	 *     Addition.Plus_1_0_0_0 returns Multi
	 *     Addition.Minus_1_0_1_0 returns Multi
	 *     Multiplication returns Multi
	 *     Multiplication.Multi_1_0_0_0 returns Multi
	 *     Multiplication.Div_1_0_1_0 returns Multi
	 *     Multiplication.Pow_1_0_2_0 returns Multi
	 *     PrimaryExpr returns Multi
	 *
	 * Constraint:
	 *     (left=Multiplication_Multi_1_0_0_0 right=PrimaryExpr)
	 */
	protected void sequence_Multiplication(ISerializationContext context, Multi semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReactionLanguagePackage.Literals.MULTI__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReactionLanguagePackage.Literals.MULTI__LEFT));
			if (transientValues.isValueTransient(semanticObject, ReactionLanguagePackage.Literals.MULTI__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReactionLanguagePackage.Literals.MULTI__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationAccess().getMultiLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationAccess().getRightPrimaryExprParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpr returns Pow
	 *     Addition returns Pow
	 *     Addition.Plus_1_0_0_0 returns Pow
	 *     Addition.Minus_1_0_1_0 returns Pow
	 *     Multiplication returns Pow
	 *     Multiplication.Multi_1_0_0_0 returns Pow
	 *     Multiplication.Div_1_0_1_0 returns Pow
	 *     Multiplication.Pow_1_0_2_0 returns Pow
	 *     PrimaryExpr returns Pow
	 *
	 * Constraint:
	 *     (left=Multiplication_Pow_1_0_2_0 right=PrimaryExpr)
	 */
	protected void sequence_Multiplication(ISerializationContext context, Pow semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReactionLanguagePackage.Literals.POW__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReactionLanguagePackage.Literals.POW__LEFT));
			if (transientValues.isValueTransient(semanticObject, ReactionLanguagePackage.Literals.POW__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReactionLanguagePackage.Literals.POW__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationAccess().getPowLeftAction_1_0_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationAccess().getRightPrimaryExprParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ObservableArithmetic returns ObservableArithmetic
	 *
	 * Constraint:
	 *     expr=ArithmeticExpr
	 */
	protected void sequence_ObservableArithmetic(ISerializationContext context, ObservableArithmetic semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReactionLanguagePackage.Literals.OBSERVABLE_ARITHMETIC__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReactionLanguagePackage.Literals.OBSERVABLE_ARITHMETIC__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObservableArithmeticAccess().getExprArithmeticExprParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ObservableBody returns ObservablePattern
	 *     ObservablePattern returns ObservablePattern
	 *
	 * Constraint:
	 *     (signature=Signature? pattern=Pattern)
	 */
	protected void sequence_ObservablePattern(ISerializationContext context, ObservablePattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Component returns Observable
	 *     ComplexElement returns Observable
	 *     Observable returns Observable
	 *
	 * Constraint:
	 *     (name=ID body=ObservableBody)
	 */
	protected void sequence_Observable(ISerializationContext context, Observable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReactionLanguagePackage.Literals.OBSERVABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReactionLanguagePackage.Literals.OBSERVABLE__NAME));
			if (transientValues.isValueTransient(semanticObject, ReactionLanguagePackage.Literals.OBSERVABLE__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReactionLanguagePackage.Literals.OBSERVABLE__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObservableAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getObservableAccess().getBodyObservableBodyParserRuleCall_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns BlankPattern
	 *
	 * Constraint:
	 *     {BlankPattern}
	 */
	protected void sequence_Pattern(ISerializationContext context, BlankPattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpr returns FunctionCall
	 *     Addition returns FunctionCall
	 *     Addition.Plus_1_0_0_0 returns FunctionCall
	 *     Addition.Minus_1_0_1_0 returns FunctionCall
	 *     Multiplication returns FunctionCall
	 *     Multiplication.Multi_1_0_0_0 returns FunctionCall
	 *     Multiplication.Div_1_0_1_0 returns FunctionCall
	 *     Multiplication.Pow_1_0_2_0 returns FunctionCall
	 *     PrimaryExpr returns FunctionCall
	 *
	 * Constraint:
	 *     (func=MathFunc expr=ArithmeticExpr)
	 */
	protected void sequence_PrimaryExpr(ISerializationContext context, FunctionCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReactionLanguagePackage.Literals.FUNCTION_CALL__FUNC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReactionLanguagePackage.Literals.FUNCTION_CALL__FUNC));
			if (transientValues.isValueTransient(semanticObject, ReactionLanguagePackage.Literals.FUNCTION_CALL__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReactionLanguagePackage.Literals.FUNCTION_CALL__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryExprAccess().getFuncMathFuncEnumRuleCall_2_1_0(), semanticObject.getFunc());
		feeder.accept(grammarAccess.getPrimaryExprAccess().getExprArithmeticExprParserRuleCall_2_3_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpr returns NumberLiteral
	 *     Addition returns NumberLiteral
	 *     Addition.Plus_1_0_0_0 returns NumberLiteral
	 *     Addition.Minus_1_0_1_0 returns NumberLiteral
	 *     Multiplication returns NumberLiteral
	 *     Multiplication.Multi_1_0_0_0 returns NumberLiteral
	 *     Multiplication.Div_1_0_1_0 returns NumberLiteral
	 *     Multiplication.Pow_1_0_2_0 returns NumberLiteral
	 *     PrimaryExpr returns NumberLiteral
	 *
	 * Constraint:
	 *     value=ArithmeticType
	 */
	protected void sequence_PrimaryExpr(ISerializationContext context, NumberLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReactionLanguagePackage.Literals.NUMBER_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReactionLanguagePackage.Literals.NUMBER_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryExprAccess().getValueArithmeticTypeParserRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpr returns VarRef
	 *     Addition returns VarRef
	 *     Addition.Plus_1_0_0_0 returns VarRef
	 *     Addition.Minus_1_0_1_0 returns VarRef
	 *     Multiplication returns VarRef
	 *     Multiplication.Multi_1_0_0_0 returns VarRef
	 *     Multiplication.Div_1_0_1_0 returns VarRef
	 *     Multiplication.Pow_1_0_2_0 returns VarRef
	 *     PrimaryExpr returns VarRef
	 *
	 * Constraint:
	 *     ref=[Variable|ID]
	 */
	protected void sequence_PrimaryExpr(ISerializationContext context, VarRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReactionLanguagePackage.Literals.VAR_REF__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReactionLanguagePackage.Literals.VAR_REF__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryExprAccess().getRefVariableIDTerminalRuleCall_3_1_0_1(), semanticObject.eGet(ReactionLanguagePackage.Literals.VAR_REF__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Rates returns Rates
	 *
	 * Constraint:
	 *     (rateForward=ArithmeticExpr (rateBackwardSet?=',' rateBackward=ArithmeticExpr)?)
	 */
	protected void sequence_Rates(ISerializationContext context, Rates semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReactionModel returns ReactionModel
	 *
	 * Constraint:
	 *     (elements+=Component elements+=Component*)+
	 */
	protected void sequence_ReactionModel(ISerializationContext context, ReactionModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RuleBody returns RuleBody
	 *
	 * Constraint:
	 *     (lhs=Pattern ruleType=RuleType rhs=Pattern rates=Rates)
	 */
	protected void sequence_RuleBody(ISerializationContext context, RuleBody semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReactionLanguagePackage.Literals.RULE_BODY__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReactionLanguagePackage.Literals.RULE_BODY__LHS));
			if (transientValues.isValueTransient(semanticObject, ReactionLanguagePackage.Literals.RULE_BODY__RULE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReactionLanguagePackage.Literals.RULE_BODY__RULE_TYPE));
			if (transientValues.isValueTransient(semanticObject, ReactionLanguagePackage.Literals.RULE_BODY__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReactionLanguagePackage.Literals.RULE_BODY__RHS));
			if (transientValues.isValueTransient(semanticObject, ReactionLanguagePackage.Literals.RULE_BODY__RATES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReactionLanguagePackage.Literals.RULE_BODY__RATES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRuleBodyAccess().getLhsPatternParserRuleCall_0_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getRuleBodyAccess().getRuleTypeRuleTypeEnumRuleCall_1_0(), semanticObject.getRuleType());
		feeder.accept(grammarAccess.getRuleBodyAccess().getRhsPatternParserRuleCall_2_0(), semanticObject.getRhs());
		feeder.accept(grammarAccess.getRuleBodyAccess().getRatesRatesParserRuleCall_3_0(), semanticObject.getRates());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RuleHead returns RuleHead
	 *
	 * Constraint:
	 *     (name=ID signature=Signature?)
	 */
	protected void sequence_RuleHead(ISerializationContext context, RuleHead semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Component returns Rule
	 *     ComplexElement returns Rule
	 *     Rule returns Rule
	 *
	 * Constraint:
	 *     (head=RuleHead body=RuleBody)
	 */
	protected void sequence_Rule(ISerializationContext context, Rule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReactionLanguagePackage.Literals.RULE__HEAD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReactionLanguagePackage.Literals.RULE__HEAD));
			if (transientValues.isValueTransient(semanticObject, ReactionLanguagePackage.Literals.RULE__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReactionLanguagePackage.Literals.RULE__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRuleAccess().getHeadRuleHeadParserRuleCall_1_0(), semanticObject.getHead());
		feeder.accept(grammarAccess.getRuleAccess().getBodyRuleBodyParserRuleCall_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Signature returns Signature
	 *
	 * Constraint:
	 *     (instances+=AgentInstance instances+=AgentInstance*)
	 */
	protected void sequence_Signature(ISerializationContext context, Signature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SiteInstanceState returns SiteInstanceState
	 *
	 * Constraint:
	 *     state=[SiteState|ID]
	 */
	protected void sequence_SiteInstanceState(ISerializationContext context, SiteInstanceState semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReactionLanguagePackage.Literals.SITE_INSTANCE_STATE__STATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReactionLanguagePackage.Literals.SITE_INSTANCE_STATE__STATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSiteInstanceStateAccess().getStateSiteStateIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ReactionLanguagePackage.Literals.SITE_INSTANCE_STATE__STATE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SiteInstance returns SiteInstance
	 *
	 * Constraint:
	 *     (site=[Site|ID] siteState=SiteInstanceState?)
	 */
	protected void sequence_SiteInstance(ISerializationContext context, SiteInstance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SiteState returns SiteState
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_SiteState(ISerializationContext context, SiteState semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReactionLanguagePackage.Literals.SITE_STATE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReactionLanguagePackage.Literals.SITE_STATE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSiteStateAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Site returns Site
	 *
	 * Constraint:
	 *     (name=ID (states+=SiteState states+=SiteState*)?)
	 */
	protected void sequence_Site(ISerializationContext context, Site semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Component returns TerminateCount
	 *     Command returns TerminateCount
	 *     TerminateCommand returns TerminateCount
	 *     TerminateBody returns TerminateCount
	 *     TerminateCount returns TerminateCount
	 *
	 * Constraint:
	 *     (signature=Signature? pattern=Pattern cnt=ArithmeticExpr)
	 */
	protected void sequence_TerminateCount(ISerializationContext context, TerminateCount semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Component returns TerminateIterations
	 *     Command returns TerminateIterations
	 *     TerminateCommand returns TerminateIterations
	 *     TerminateBody returns TerminateIterations
	 *     TerminateIterations returns TerminateIterations
	 *
	 * Constraint:
	 *     iterations=ArithmeticExpr
	 */
	protected void sequence_TerminateIterations(ISerializationContext context, TerminateIterations semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReactionLanguagePackage.Literals.TERMINATE_ITERATIONS__ITERATIONS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReactionLanguagePackage.Literals.TERMINATE_ITERATIONS__ITERATIONS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTerminateIterationsAccess().getIterationsArithmeticExprParserRuleCall_2_0(), semanticObject.getIterations());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Component returns TerminateTime
	 *     Command returns TerminateTime
	 *     TerminateCommand returns TerminateTime
	 *     TerminateBody returns TerminateTime
	 *     TerminateTime returns TerminateTime
	 *
	 * Constraint:
	 *     time=ArithmeticExpr
	 */
	protected void sequence_TerminateTime(ISerializationContext context, TerminateTime semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReactionLanguagePackage.Literals.TERMINATE_TIME__TIME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReactionLanguagePackage.Literals.TERMINATE_TIME__TIME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTerminateTimeAccess().getTimeArithmeticExprParserRuleCall_2_0(), semanticObject.getTime());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Component returns Variable
	 *     ComplexElement returns Variable
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     (name=ID value=ArithmeticExpr)
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReactionLanguagePackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReactionLanguagePackage.Literals.VARIABLE__NAME));
			if (transientValues.isValueTransient(semanticObject, ReactionLanguagePackage.Literals.VARIABLE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReactionLanguagePackage.Literals.VARIABLE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVariableAccess().getValueArithmeticExprParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Wildcard returns Wildcard
	 *
	 * Constraint:
	 *     (anything?=ANYTHING | nothing?=NULL)
	 */
	protected void sequence_Wildcard(ISerializationContext context, Wildcard semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
